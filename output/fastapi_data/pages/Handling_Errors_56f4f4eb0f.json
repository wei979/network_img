{
  "url": "https://fastapi.tiangolo.com/tutorial/handling-errors/",
  "title": "Handling Errors¶",
  "content": "There are many situations in which you need to notify an error to a client that is using your API.\n\nThis client could be a browser with a frontend, a code from someone else, an IoT device, etc.\n\nYou could need to tell the client that:\n\nIn these cases, you would normally return an HTTP status code in the range of 400 (from 400 to 499).\n\nThis is similar to the 200 HTTP status codes (from 200 to 299). Those \"200\" status codes mean that somehow there was a \"success\" in the request.\n\nThe status codes in the 400 range mean that there was an error from the client.\n\nRemember all those \"404 Not Found\" errors (and jokes)?\n\nTo return HTTP responses with errors to the client you use HTTPException.\n\nHTTPException is a normal Python exception with additional data relevant for APIs.\n\nBecause it's a Python exception, you don't return it, you raise it.\n\nThis also means that if you are inside a utility function that you are calling inside of your path operation function, and you raise the HTTPException from inside of that utility function, it won't run the rest of the code in the path operation function, it will terminate that request right away and send the HTTP error from the HTTPException to the client.\n\nThe benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security.\n\nIn this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of 404:\n\nIf the client requests http://example.com/items/foo (an item_id \"foo\"), that client will receive an HTTP status code of 200, and a JSON response of:\n\nBut if the client requests http://example.com/items/bar (a non-existent item_id \"bar\"), that client will receive an HTTP status code of 404 (the \"not found\" error), and a JSON response of:\n\nWhen raising an HTTPException, you can pass any value that can be converted to JSON as the parameter detail, not only str.\n\nYou could pass a dict, a list, etc.\n\nThey are handled automatically by FastAPI and converted to JSON.\n\nThere are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.\n\nYou probably won't need to use it directly in your code.\n\nBut in case you needed it for an advanced scenario, you can add custom headers:\n\nYou can add custom exception handlers with the same exception utilities from Starlette.\n\nLet's say you have a custom exception UnicornException that you (or a library you use) might raise.\n\nAnd you want to handle this exception globally with FastAPI.\n\nYou could add a custom exception handler with @app.exception_handler():\n\nHere, if you request /unicorns/yolo, the path operation will raise a UnicornException.\n\nBut it will be handled by the unicorn_exception_handler.\n\nSo, you will receive a clean error, with an HTTP status code of 418 and a JSON content of:\n\nYou could also use from starlette.requests import Request and from starlette.responses import JSONResponse.\n\nFastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request.\n\nFastAPI has some default exception handlers.\n\nThese handlers are in charge of returning the default JSON responses when you raise an HTTPException and when the request has invalid data.\n\nYou can override these exception handlers with your own.\n\nWhen a request contains invalid data, FastAPI internally raises a RequestValidationError.\n\nAnd it also includes a default exception handler for it.\n\nTo override it, import the RequestValidationError and use it with @app.exception_handler(RequestValidationError) to decorate the exception handler.\n\nThe exception handler will receive a Request and the exception.\n\nNow, if you go to /items/foo, instead of getting the default JSON error with:\n\nyou will get a text version, with:\n\nThese are technical details that you might skip if it's not important for you now.\n\nRequestValidationError is a sub-class of Pydantic's ValidationError.\n\nFastAPI uses it so that, if you use a Pydantic model in response_model, and your data has an error, you will see the error in your log.\n\nBut the client/user will not see it. Instead, the client will receive an \"Internal Server Error\" with an HTTP status code 500.\n\nIt should be this way because if you have a Pydantic ValidationError in your response or anywhere in your code (not in the client's request), it's actually a bug in your code.\n\nAnd while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.\n\nThe same way, you can override the HTTPException handler.\n\nFor example, you could want to return a plain text response instead of JSON for these errors:\n\nYou could also use from starlette.responses import PlainTextResponse.\n\nFastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.\n\nThe RequestValidationError contains the body it received with invalid data.\n\nYou could use it while developing your app to log the body and debug it, return it to the user, etc.\n\nNow try sending an invalid item like:\n\nYou will receive a response telling you that the data is invalid containing the received body:\n\nFastAPI has its own HTTPException.\n\nAnd FastAPI's HTTPException error class inherits from Starlette's HTTPException error class.\n\nThe only difference is that FastAPI's HTTPException accepts any JSON-able data for the detail field, while Starlette's HTTPException only accepts strings for it.\n\nSo, you can keep raising FastAPI's HTTPException as normally in your code.\n\nBut when you register an exception handler, you should register it for Starlette's HTTPException.\n\nThis way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette HTTPException, your handler will be able to catch and handle it.\n\nIn this example, to be able to have both HTTPExceptions in the same code, Starlette's exceptions is renamed to StarletteHTTPException:\n\nIf you want to use the exception along with the same default exception handlers from FastAPI, you can import and reuse the default exception handlers from fastapi.exception_handlers:\n\nIn this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers.",
  "headings": [
    {
      "level": "h1",
      "text": "Handling Errors¶",
      "id": "handling-errors"
    },
    {
      "level": "h2",
      "text": "Use HTTPException¶",
      "id": "use-httpexception"
    },
    {
      "level": "h3",
      "text": "Import HTTPException¶",
      "id": "import-httpexception"
    },
    {
      "level": "h3",
      "text": "Raise an HTTPException in your code¶",
      "id": "raise-an-httpexception-in-your-code"
    },
    {
      "level": "h3",
      "text": "The resulting response¶",
      "id": "the-resulting-response"
    },
    {
      "level": "h2",
      "text": "Add custom headers¶",
      "id": "add-custom-headers"
    },
    {
      "level": "h2",
      "text": "Install custom exception handlers¶",
      "id": "install-custom-exception-handlers"
    },
    {
      "level": "h2",
      "text": "Override the default exception handlers¶",
      "id": "override-the-default-exception-handlers"
    },
    {
      "level": "h3",
      "text": "Override request validation exceptions¶",
      "id": "override-request-validation-exceptions"
    },
    {
      "level": "h4",
      "text": "RequestValidationError vs ValidationError¶",
      "id": "requestvalidationerror-vs-validationerror"
    },
    {
      "level": "h3",
      "text": "Override the HTTPException error handler¶",
      "id": "override-the-httpexception-error-handler"
    },
    {
      "level": "h3",
      "text": "Use the RequestValidationError body¶",
      "id": "use-the-requestvalidationerror-body"
    },
    {
      "level": "h4",
      "text": "FastAPI's HTTPException vs Starlette's HTTPException¶",
      "id": "fastapis-httpexception-vs-starlettes-httpexception"
    },
    {
      "level": "h3",
      "text": "Reuse FastAPI's exception handlers¶",
      "id": "reuse-fastapis-exception-handlers"
    }
  ],
  "code_samples": [
    {
      "code": "from fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nitems = {\"foo\": \"The Foo Wrestlers\"}\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: str):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item\": items[item_id]}",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nitems = {\"foo\": \"The Foo Wrestlers\"}\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: str):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item\": items[item_id]}",
      "language": "python"
    },
    {
      "code": "{\n  \"item\": \"The Foo Wrestlers\"\n}",
      "language": "unknown"
    },
    {
      "code": "{\n  \"detail\": \"Item not found\"\n}",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nitems = {\"foo\": \"The Foo Wrestlers\"}\n\n\n@app.get(\"/items-header/{item_id}\")\nasync def read_item_header(item_id: str):\n    if item_id not in items:\n        raise HTTPException(\n            status_code=404,\n            detail=\"Item not found\",\n            headers={\"X-Error\": \"There goes my error\"},\n        )\n    return {\"item\": items[item_id]}",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\n\nclass UnicornException(Exception):\n    def __init__(self, name: str):\n        self.name = name\n\n\napp = FastAPI()\n\n\n@app.exception_handler(UnicornException)\nasync def unicorn_exception_handler(request: Request, exc: UnicornException):\n    return JSONResponse(\n        status_code=418,\n        content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"},\n    )\n\n\n@app.get(\"/unicorns/{name}\")\nasync def read_unicorn(name: str):\n    if name == \"yolo\":\n        raise UnicornException(name=name)\n    return {\"unicorn_name\": name}",
      "language": "python"
    },
    {
      "code": "{\"message\": \"Oops! yolo did something. There goes a rainbow...\"}",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI, HTTPException\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import PlainTextResponse\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\napp = FastAPI()\n\n\n@app.exception_handler(StarletteHTTPException)\nasync def http_exception_handler(request, exc):\n    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request, exc):\n    return PlainTextResponse(str(exc), status_code=400)\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\")\n    return {\"item_id\": item_id}",
      "language": "python"
    },
    {
      "code": "{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"path\",\n                \"item_id\"\n            ],\n            \"msg\": \"value is not a valid integer\",\n            \"type\": \"type_error.integer\"\n        }\n    ]\n}",
      "language": "unknown"
    },
    {
      "code": "1 validation error\npath -> item_id\n  value is not a valid integer (type=type_error.integer)",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI, HTTPException\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import PlainTextResponse\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\napp = FastAPI()\n\n\n@app.exception_handler(StarletteHTTPException)\nasync def http_exception_handler(request, exc):\n    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request, exc):\n    return PlainTextResponse(str(exc), status_code=400)\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\")\n    return {\"item_id\": item_id}",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, Request\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\n    )\n\n\nclass Item(BaseModel):\n    title: str\n    size: int\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item",
      "language": "python"
    },
    {
      "code": "{\n  \"title\": \"towel\",\n  \"size\": \"XL\"\n}",
      "language": "unknown"
    },
    {
      "code": "{\n  \"detail\": [\n    {\n      \"loc\": [\n        \"body\",\n        \"size\"\n      ],\n      \"msg\": \"value is not a valid integer\",\n      \"type\": \"type_error.integer\"\n    }\n  ],\n  \"body\": {\n    \"title\": \"towel\",\n    \"size\": \"XL\"\n  }\n}",
      "language": "unknown"
    },
    {
      "code": "from starlette.exceptions import HTTPException as StarletteHTTPException",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, HTTPException\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\napp = FastAPI()\n\n\n@app.exception_handler(StarletteHTTPException)\nasync def custom_http_exception_handler(request, exc):\n    print(f\"OMG! An HTTP error!: {repr(exc)}\")\n    return await http_exception_handler(request, exc)\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request, exc):\n    print(f\"OMG! The client sent invalid data!: {exc}\")\n    return await request_validation_exception_handler(request, exc)\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\")\n    return {\"item_id\": item_id}",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/tutorial/handling-errors/"
  ]
}