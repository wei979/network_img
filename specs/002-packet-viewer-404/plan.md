# Implementation Plan: Fix Packet Viewer 404 Error for Timeout Connections

**Branch**: `002-packet-viewer-404` | **Date**: 2025-11-17 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-packet-viewer-404/spec.md`

## Summary

Fix the packet viewer 404 error that occurs when users click timeout connections in the MindMap visualization. The bug stems from timeout timelines lacking `packetRefs` in their stages, causing `_build_connection_packets()` to create empty packet lists. The solution adds a fallback mechanism to extract packets by parsing the connection ID and scanning the packet list when `packetRefs` are unavailable.

**Technical Approach**: Implement hybrid packet extraction in `network_analyzer.py` that uses `packetRefs` as the primary method and falls back to 5-tuple-based packet scanning for timeout connections. This maintains backward compatibility while fixing the bug without requiring changes to the timeout detection logic.

## Technical Context

**Language/Version**: Python 3.13
**Primary Dependencies**: FastAPI 0.115+, Scapy 2.6+, APScheduler 3.10+
**Storage**: JSON files (`public/data/{sessionId}/connection_packets.json`)
**Testing**: pytest 8.3+
**Target Platform**: Windows/Linux server (FastAPI backend)
**Project Type**: Web application (React frontend + FastAPI backend)
**Performance Goals**: Packet extraction < 500ms for PCAP files with 10K packets
**Constraints**: Backward compatible with existing connection_packets.json files
**Scale/Scope**: Typical PCAP files contain 1K-50K packets with 10-500 timeout connections

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Status**: N/A - No project constitution file exists yet

This feature does not violate any established principles as no constitution has been defined. Future features should consider establishing a constitution to guide architecture decisions.

## Project Structure

### Documentation (this feature)

```text
specs/002-packet-viewer-404/
├── plan.md              # This file (/speckit.plan command output)
├── spec.md              # Feature specification (already exists)
├── research.md          # Phase 0 output (created)
├── data-model.md        # Phase 1 output (created)
├── quickstart.md        # Phase 1 output (will be generated)
├── contracts/           # Phase 1 output (will be generated)
│   ├── _find_packets_by_connection_id.md
│   └── _build_connection_packets.md
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
# Web application structure (frontend + backend)
backend/ (Python FastAPI)
├── network_analyzer.py           # MODIFIED: Add packet extraction fallback
├── analysis_server.py            # NO CHANGES: API already handles all connection types
└── requirements.txt              # NO CHANGES: No new dependencies

frontend/ (React + Vite)
├── src/
│   ├── MindMap.jsx              # NO CHANGES: Already sends correct connection IDs
│   └── components/              # NO CHANGES: Frontend works correctly
└── public/
    └── data/                    # Test fixtures
        ├── protocol_timeline_sample.json    # REFERENCE: Contains timeout examples
        └── connection_packets.json          # OUTPUT: Generated by backend

tests/
├── unit/
│   ├── test_find_packets_by_connection_id.py    # NEW: Test fallback method
│   └── test_build_connection_packets.py         # NEW: Test timeout extraction
├── integration/
│   └── test_packet_viewer_api.py                # NEW: Test API with timeout connections
└── fixtures/
    ├── timeout_connection.json                  # NEW: Test data
    └── sample_small.pcap                        # EXISTING: Small test PCAP file
```

**Structure Decision**: Web application with clear frontend/backend separation. Backend changes isolated to `network_analyzer.py` packet extraction logic. No frontend changes required as the bug is purely backend packet data generation.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

N/A - No constitution violations as no constitution exists.

## Phase 0: Research & Discovery

**Status**: ✅ COMPLETED

**Objective**: Understand the root cause of packet viewer 404 errors for timeout connections and identify the best fix approach.

### Research Deliverables

1. **Problem Analysis** (in [research.md](./research.md))
   - Root cause: Timeout timelines lack `packetRefs` in stages
   - ID format comparison: Standard vs. timeout connections
   - Data flow analysis: Timeline generation → packet extraction → API response

2. **Solution Approaches** (in [research.md](./research.md))
   - ✅ **Approach 3 (Recommended)**: Hybrid fallback in `_build_connection_packets()`
   - Alternative 1: Add packetRefs to timeout detection (future enhancement)
   - Alternative 2: Parse ID and scan packets (less efficient)

3. **Key Findings**
   - Timeout IDs include trailing packet index: `timeout-{srcIp}-{srcPort}-{dstIp}-{dstPort}-{packetIndex}`
   - Standard connection IDs: `{protocol}-{srcIp}-{srcPort}-{dstIp}-{dstPort}`
   - Timeout stages missing `packetRefs` → empty packet lists in connection_packets.json
   - API already handles all connection types correctly (no backend API changes needed)
   - Frontend correctly requests timeout connection packets (no frontend changes needed)

### Research Questions Answered

**Q1**: Why do timeout connections return 404?
**A**: `_build_connection_packets()` relies on `packetRefs` from stages, which timeout timelines don't have. This results in empty packet lists, and the connection ID isn't added to connection_packets.json, causing 404.

**Q2**: What's the difference between timeout and standard connection IDs?
**A**: Timeout IDs have a trailing packet index (e.g., `-4632`), while standard IDs end with the destination port.

**Q3**: Can we fix this without changing timeout detection logic?
**A**: Yes, by adding a fallback in `_build_connection_packets()` that parses the connection ID and scans packets when `packetRefs` are unavailable.

**Q4**: Will this impact performance?
**A**: Minimal impact. Packet scanning for timeout connections is O(N×M) where N=timeouts (~50), M=packets (~10K), resulting in ~500K comparisons (<500ms).

**Q5**: Are there security concerns with parsing connection IDs?
**A**: Low risk. Input validation on port numbers (0-65535) and graceful handling of malformed IDs prevents exploitation.

## Phase 1: Design & Contracts

**Status**: ✅ COMPLETED

### 1.1 Data Model

**Deliverable**: [data-model.md](./data-model.md)

**Key Entities**:

1. **Connection**
   - Attributes: id, protocol, protocolType, startEpochMs, endEpochMs, stages, metrics
   - ID formats: Standard (`tcp-{ip}-{port}-{ip}-{port}`) vs. Timeout (`timeout-{ip}-{port}-{ip}-{port}-{index}`)

2. **Stage**
   - Attributes: key, label, direction, durationMs, packetRefs (optional)
   - **Critical**: packetRefs is REQUIRED for standard connections, MISSING for timeout

3. **Packet**
   - Attributes: index, timestamp, relativeTime, length, fiveTuple, headers, payload
   - Extracted from PCAP using Scapy

4. **FiveTuple**
   - Attributes: srcIp, srcPort, dstIp, dstPort, protocol
   - Used for packet matching in fallback logic

**Data Flow**:
```
PCAP → load_packets() → generate_protocol_timelines() → _detect_timeouts() (no packetRefs)
                                                      → _build_connection_packets() (fallback)
                                                      → connection_packets.json
                                                      → GET /api/packets/{id}
```

### 1.2 Component Architecture

**Modified Components**:

1. **NetworkAnalyzer** (`network_analyzer.py`)
   - **New Method**: `_find_packets_by_connection_id(connection_id: str) -> set`
   - **Modified Method**: `_build_connection_packets(timelines: list)`
   - **Unchanged Methods**: `_detect_timeouts()`, `_extract_tcp_handshakes()`, etc.

2. **No Changes Required**:
   - `analysis_server.py`: API already handles all connection types
   - Frontend components: Already send correct connection IDs
   - Database/storage: JSON file format unchanged

**Design Principles**:
- **Backward Compatibility**: Existing packet extraction (via packetRefs) unchanged
- **Fail-Safe**: Fallback only activates when packetRefs unavailable
- **Separation of Concerns**: Packet scanning logic isolated in helper method
- **Testability**: New methods are pure functions (testable in isolation)

### 1.3 Algorithm Design

**Primary Algorithm**: Extract packets using packetRefs (existing)

```python
# Existing logic (unchanged)
for stage in timeline['stages']:
    if 'packetRefs' in stage:
        packet_indices.update(stage['packetRefs'])
```

**Fallback Algorithm**: Extract packets by 5-tuple scanning (new)

```python
def _find_packets_by_connection_id(self, connection_id: str) -> set:
    """
    Parse connection ID → Extract 5-tuple → Scan packets → Return matching indices

    Handles:
    - Standard: tcp-10.1.1.14-5434-210.71.227.211-443
    - Timeout: timeout-10.1.1.14-9492-172.64.153.46-443-4632
    """
    # 1. Parse ID
    parts = connection_id.split('-')

    # 2. Extract 5-tuple based on format
    if parts[0] == 'timeout':
        if len(parts) < 6:
            return set()  # Invalid format
        src_ip, src_port, dst_ip, dst_port = parts[1], int(parts[2]), parts[3], int(parts[4])
    else:
        if len(parts) < 5:
            return set()  # Invalid format
        src_ip, src_port, dst_ip, dst_port = parts[1], int(parts[2]), parts[3], int(parts[4])

    # 3. Scan packets for matches (bidirectional)
    matched = set()
    for idx, packet in enumerate(self.packets):
        if matches_5tuple(packet, src_ip, src_port, dst_ip, dst_port):
            matched.add(idx)

    return matched
```

**Bidirectional Matching**:
```python
# Match BOTH directions
matches = (
    (ip.src == src_ip and sport == src_port and ip.dst == dst_ip and dport == dst_port) or
    (ip.src == dst_ip and sport == dst_port and ip.dst == src_ip and dport == src_port)
)
```

### 1.4 API Contracts

**Contract 1**: `_find_packets_by_connection_id(connection_id: str) -> set`

See: `contracts/_find_packets_by_connection_id.md`

**Inputs**:
- `connection_id` (string): Connection identifier (standard or timeout format)

**Outputs**:
- `set[int]`: Set of packet indices matching the connection (empty if none found)

**Behavior**:
- Parse connection ID to extract 5-tuple
- Handle both standard and timeout ID formats
- Scan packets bidirectionally (src→dst and dst→src)
- Return empty set for malformed IDs (no exceptions)

**Edge Cases**:
- Malformed ID → return empty set
- Invalid port (< 0 or > 65535) → return empty set (after validation)
- No matching packets → return empty set

---

**Contract 2**: `_build_connection_packets(timelines: list) -> None`

See: `contracts/_build_connection_packets.md`

**Inputs**:
- `timelines` (list): List of timeline dictionaries from `generate_protocol_timelines()`

**Outputs**:
- None (modifies `self.analysis_results['connection_packets']`)

**Behavior**:
1. For each timeline:
   - **Primary**: Extract packet indices from stage['packetRefs']
   - **Fallback**: If no packetRefs, call `_find_packets_by_connection_id()`
2. Extract packet details using `_extract_packet_details()`
3. Calculate relative timestamps
4. Store in `self.analysis_results['connection_packets'][connection_id]`

**Changes from Current**:
- Add fallback logic after packetRefs extraction
- No changes to packet detail extraction or relative time calculation

### 1.5 Testing Strategy

**Unit Tests**:

1. **test_find_packets_by_connection_id.py**
   - Test standard connection ID parsing
   - Test timeout connection ID parsing
   - Test bidirectional packet matching
   - Test malformed ID handling
   - Test empty packet list (no matches)

2. **test_build_connection_packets.py**
   - Test primary path (with packetRefs) still works
   - Test fallback path (without packetRefs) for timeout
   - Test mixed timelines (some with, some without packetRefs)
   - Test relative time calculation

**Integration Tests**:

3. **test_packet_viewer_api.py**
   - Test GET /api/packets/{connection_id} for timeout connections
   - Test pagination (offset, limit) with timeout packets
   - Test 404 handling for invalid connection IDs
   - Test packet count matches timeline metrics

**Test Data**:
- Use existing `public/data/protocol_timeline_sample.json` (contains 52+ timeout connections)
- Create minimal test fixture with known timeout connection
- Generate small test PCAP file with timeout scenario

### 1.6 Migration & Rollout

**Phase 1: Development**
- Implement `_find_packets_by_connection_id()` method
- Modify `_build_connection_packets()` with fallback
- Write unit tests (target: 90%+ coverage)

**Phase 2: Testing**
- Run integration tests with existing PCAP fixtures
- Verify all connection types (TCP, UDP, HTTP, HTTPS, DNS, timeout)
- Performance benchmarking (target: < 500ms for 10K packets)

**Phase 3: Deployment**
- No database migrations (JSON file-based)
- No API contract changes (backward compatible)
- Users re-analyze PCAP files to generate updated connection_packets.json

**Rollback Plan**:
- Revert `network_analyzer.py` changes
- Old connection_packets.json files remain valid (no timeout data)
- No data loss or corruption risk

## Phase 2: Task Generation

**Status**: PENDING

**Note**: Tasks will be generated using the `/speckit.tasks` command after plan approval.

**Expected Task Categories**:
1. **Implementation Tasks**
   - Implement `_find_packets_by_connection_id()` method
   - Modify `_build_connection_packets()` with fallback logic
   - Add input validation and error handling

2. **Testing Tasks**
   - Write unit tests for new method
   - Write integration tests for API
   - Create test fixtures and sample data

3. **Documentation Tasks**
   - Update code comments and docstrings
   - Create quickstart guide for testing
   - Document edge cases and limitations

4. **Validation Tasks**
   - Run pytest with coverage report
   - Performance benchmarking with large PCAP files
   - Manual testing with frontend

## Success Criteria

From [spec.md](./spec.md):

- **SC-001**: ✅ 100% of timeout connections clicked in MindMap successfully open packet viewer without 404 errors
- **SC-002**: ✅ Packet viewer displays complete packet data (5-tuple, headers, payload) for all connection types within 1 second of click
- **SC-003**: ✅ Zero 404 errors occur when clicking any connection type in MindMap after fix is deployed
- **SC-004**: ✅ Users can successfully browse all packets for timeout connections using pagination controls

**Acceptance Test**:
1. Upload PCAP file with timeout connections
2. Click timeout connection in MindMap
3. Verify packet viewer opens with packet list
4. Verify all packets show 5-tuple, headers, payload
5. Verify pagination works correctly

## Dependencies

**External Libraries** (no new dependencies):
- scapy 2.6+: Already used for packet parsing
- pytest 8.3+: Already used for testing
- FastAPI 0.115+: Already used for API

**Internal Modules**:
- `network_analyzer.py`: Core implementation (modified)
- `analysis_server.py`: API layer (unchanged)
- Frontend components: MindMap, packet viewer (unchanged)

**Data Dependencies**:
- PCAP/PCAPNG files: Input data source
- protocol_timeline_sample.json: Timeline data (unchanged)
- connection_packets.json: Packet data (regenerated after fix)

## Risk Assessment

### High Priority Risks

**R1: Performance Degradation**
- **Impact**: Packet scanning may be slow for large PCAP files (100K+ packets)
- **Probability**: Medium (typical files are 1K-50K packets)
- **Mitigation**:
  - Add early termination when packet count reaches metrics.packetCount
  - Document performance limits (max 100K packets recommended)
  - Consider adding 5-tuple index in future (see Future Enhancements)

**R2: Backward Compatibility**
- **Impact**: Existing connection_packets.json files won't have timeout data
- **Probability**: High (all existing files lack timeout packets)
- **Mitigation**:
  - Document re-analysis requirement
  - API returns 404 for missing connections (expected behavior)
  - No breaking changes to API contract

### Medium Priority Risks

**R3: Bidirectional Matching Edge Cases**
- **Impact**: May miss packets in rare network scenarios
- **Probability**: Low (5-tuple matching is standard)
- **Mitigation**: Comprehensive unit tests with bidirectional test cases

**R4: Malformed Connection ID Handling**
- **Impact**: Potential crashes or security issues
- **Probability**: Very Low (IDs generated by backend, not user input)
- **Mitigation**: Input validation, graceful error handling, return empty set

### Low Priority Risks

**R5: Memory Usage**
- **Impact**: Loading large packet lists into memory
- **Probability**: Very Low (pagination limits to 100 packets)
- **Mitigation**: API pagination enforced, memory profiling during tests

## Future Enhancements

### Enhancement 1: Add packetRefs to Timeout Detection

**Description**: Modify `_detect_timeouts()` to track packet indices and include them in stage['packetRefs'].

**Benefit**: Eliminates packet scanning fallback, improves performance.

**Implementation**:
```python
# In _detect_timeouts()
conn['packet_indices'] = conn.get('packet_indices', set())
conn['packet_indices'].add(index)

# When creating timeline:
'stages': [{
    'key': 'waiting',
    'packetRefs': list(conn['packet_indices'])  # ADD THIS
}]
```

**Effort**: Medium (requires tracking packet indices during timeout detection)

### Enhancement 2: Build 5-Tuple Index

**Description**: Create connection index during packet loading for O(1) lookup.

**Benefit**: Faster packet extraction for timeout connections (current O(N) → O(1)).

**Implementation**:
```python
self.connection_index = defaultdict(set)

# During load_packets():
for idx, packet in enumerate(self.packets):
    if packet.haslayer(IP) and (packet.haslayer(TCP) or packet.haslayer(UDP)):
        key = (ip.src, tcp.sport, ip.dst, tcp.dport)
        self.connection_index[key].add(idx)
```

**Effort**: Low (one-time indexing during packet load)

### Enhancement 3: Packet Range Metadata

**Description**: Add packet index range to timeline metrics.

**Benefit**: Frontend can display "Packets 4629-4632" without loading all packets.

**Implementation**:
```python
'metrics': {
    'packetCount': 5,
    'packetRange': [4629, 4632]  # [first, last]
}
```

**Effort**: Very Low (calculate min/max during packet extraction)

## Assumptions

1. **User Behavior**: Users will re-analyze PCAP files after fix is deployed to get updated packet data
2. **Scale**: Typical PCAP files contain < 50K packets and < 500 timeout connections
3. **Frontend**: Frontend correctly handles empty packet lists and 404 responses (already verified)
4. **API**: Backend API correctly routes requests for all connection types (already verified)
5. **Data Integrity**: Connection IDs in timelines match actual packet 5-tuples in PCAP
6. **Network Patterns**: Timeout connections represent < 10% of total connections (based on sample data)

## Open Questions

**Q1**: Should we enforce a maximum packet count limit for timeout connections?
**Decision Pending**: Consider limiting to 1000 packets to prevent excessive scanning.

**Q2**: Should we add logging for fallback path usage?
**Recommendation**: Yes, add debug logging to track how often fallback is used.

**Q3**: Should we implement Enhancement 1 (packetRefs in timeouts) immediately?
**Recommendation**: No, implement as separate feature after this fix is validated.

## Appendix: Reference Documents

- **Feature Spec**: [spec.md](./spec.md) - User scenarios, requirements, success criteria
- **Research**: [research.md](./research.md) - Root cause analysis, solution approaches
- **Data Model**: [data-model.md](./data-model.md) - Entity definitions, data flow
- **Contracts**: [contracts/](./contracts/) - Method contracts and interfaces
- **Quickstart**: [quickstart.md](./quickstart.md) - Developer setup and testing guide
