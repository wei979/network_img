我來為您規劃完整的通訊協議圖形化顯示方案！

## 📋 通訊協議視覺化規劃方案

### 一、核心協議視覺化設計

#### 1. **TCP 三次握手 (3-Way Handshake)**
```
視覺呈現：
- 階段1：藍色圓點 → (SYN) 從客戶端往伺服器
- 階段2：綠色圓點 ← (SYN-ACK) 從伺服器回客戶端
- 階段3：黃色圓點 → (ACK) 從客戶端往伺服器
- 完成後：連線變為綠色實線，雙向數據流動

狀態文字：
"SYN 發送中" → "SYN-ACK 回應" → "ACK 確認" → "連線已建立"

時間軸：每個階段 0.5秒，總計 1.5秒
```

#### 2. **TCP 四次揮手 (4-Way Handshake - 斷線)**
```
視覺呈現：
- 階段1：橙色圓點 → (FIN) 
- 階段2：橙色圓點 ← (ACK)
- 階段3：橙色圓點 ← (FIN)
- 階段4：橙色圓點 → (ACK)
- 完成後：連線淡出消失

狀態文字：
"請求斷線" → "確認斷線" → "對方斷線" → "完全關閉"

顏色漸變：綠色 → 橙色 → 灰色 → 消失
```

#### 3. **DNS 查詢 (DNS Query/Response)**
```
視覺呈現：
- 查詢：紫色圓點 → (Query: example.com)
- 等待：圓點在中間旋轉（0.1-0.3秒）
- 回應：紫色圓點 ← (Response: 93.184.216.34)
- 成功：連線閃爍一次綠光

狀態文字：
"DNS 查詢中" → "解析中..." → "解析成功" / "解析失敗"

特殊效果：成功時顯示解析的 IP 地址
```

#### 4. **HTTP/HTTPS 請求**
```
視覺呈現：
- TLS握手（HTTPS）：金色圓點往返 3 次（簡化版）
- 請求：藍色圓點 → (GET/POST/PUT/DELETE)
- 等待：虛線脈衝
- 回應：藍色圓點 ← (200/404/500)

狀態文字：
"TLS 握手" → "發送請求" → "等待回應" → "200 OK" / "404 Not Found"

狀態碼顏色：
- 2xx: 綠色
- 3xx: 藍色
- 4xx: 橙色
- 5xx: 紅色
```

#### 5. **連線超時 (Timeout)**
```
視覺呈現：
- 第1秒：黃色圓點慢速移動
- 第2秒：橙色圓點更慢
- 第3秒：紅色圓點幾乎停滯
- 第4秒：圓點開始閃爍
- 第5秒：連線變為虛線，顯示 ⚠️

狀態文字：
"等待回應..." → "回應延遲" → "連線超時" → "重試中" / "連線失敗"

連線顏色漸變：綠(0s) → 黃(2s) → 橙(3s) → 紅(4s+)
```

#### 6. **UDP 傳輸**
```
視覺呈現：
- 單向：小圓點快速連續發射 →→→
- 無回應：沒有反向圓點
- 特徵：虛線連接，表示不可靠

狀態文字：
"UDP 傳輸中"

顏色：淡藍色，半透明
```

#### 7. **ICMP Ping**
```
視覺呈現：
- Echo Request：白色圓點 → 快速
- Echo Reply：白色圓點 ← 快速
- 延遲顯示：RTT 時間標示在連線上

狀態文字：
"Ping..." → "Pong! (12ms)" / "Request Timeout"

成功：綠色閃爍
失敗：紅色 X 符號
```

#### 8. **SSH/TLS 加密連線**
```
視覺呈現：
- 握手：金色鎖頭圖示閃爍
- 數據傳輸：加密盾牌圖示的圓點
- 連線：有鎖鏈紋理的線條

狀態文字：
"加密握手中" → "建立安全通道" → "加密傳輸中"

特效：連線帶有流動的加密圖案
```

---

### 二、實作架構設計

#### **資料結構**
```javascript
const protocolStates = {
  'tcp-handshake': {
    stages: [
      { step: 'SYN', direction: 'forward', color: '#3b82f6', duration: 500 },
      { step: 'SYN-ACK', direction: 'backward', color: '#10b981', duration: 500 },
      { step: 'ACK', direction: 'forward', color: '#f59e0b', duration: 500 }
    ],
    finalState: 'established',
    totalDuration: 1500
  },
  
  'tcp-teardown': {
    stages: [
      { step: 'FIN', direction: 'forward', color: '#f97316', duration: 400 },
      { step: 'ACK', direction: 'backward', color: '#f97316', duration: 400 },
      { step: 'FIN', direction: 'backward', color: '#f97316', duration: 400 },
      { step: 'ACK', direction: 'forward', color: '#f97316', duration: 400 }
    ],
    finalState: 'closed',
    totalDuration: 1600
  },
  
  'dns-query': {
    stages: [
      { step: 'Query', direction: 'forward', color: '#8b5cf6', duration: 100 },
      { step: 'Resolving', direction: 'wait', color: '#8b5cf6', duration: 200 },
      { step: 'Response', direction: 'backward', color: '#8b5cf6', duration: 100 }
    ],
    finalState: 'resolved',
    totalDuration: 400
  },
  
  'http-request': {
    stages: [
      { step: 'TLS Handshake', direction: 'both', color: '#fbbf24', duration: 800 },
      { step: 'GET', direction: 'forward', color: '#06b6d4', duration: 200 },
      { step: 'Processing', direction: 'wait', color: '#06b6d4', duration: 300 },
      { step: '200 OK', direction: 'backward', color: '#10b981', duration: 200 }
    ],
    finalState: 'completed',
    totalDuration: 1500
  },
  
  'timeout': {
    stages: [
      { step: 'Request', direction: 'forward', color: '#fbbf24', duration: 1000 },
      { step: 'Waiting', direction: 'wait', color: '#f59e0b', duration: 2000 },
      { step: 'Timeout', direction: 'none', color: '#ef4444', duration: 1000 }
    ],
    finalState: 'timeout',
    totalDuration: 4000
  }
};
```

#### **動畫控制器**
```javascript
class ProtocolAnimationController {
  constructor(connection, protocolType) {
    this.connection = connection;
    this.protocol = protocolStates[protocolType];
    this.currentStage = 0;
    this.elapsedTime = 0;
  }
  
  update(deltaTime) {
    this.elapsedTime += deltaTime;
    
    // 計算當前階段
    let cumulativeTime = 0;
    for (let i = 0; i < this.protocol.stages.length; i++) {
      cumulativeTime += this.protocol.stages[i].duration;
      if (this.elapsedTime < cumulativeTime) {
        this.currentStage = i;
        break;
      }
    }
    
    // 返回當前圓點位置和狀態
    return this.calculateCirclePosition();
  }
  
  calculateCirclePosition() {
    const stage = this.protocol.stages[this.currentStage];
    const stageProgress = this.getStageProgress();
    
    if (stage.direction === 'forward') {
      return { x: stageProgress, y: 0, color: stage.color, label: stage.step };
    } else if (stage.direction === 'backward') {
      return { x: 1 - stageProgress, y: 0, color: stage.color, label: stage.step };
    } else if (stage.direction === 'wait') {
      return { x: 0.5, y: 0, color: stage.color, label: stage.step, spinning: true };
    }
  }
}
```

---

### 三、UI/UX 設計建議

#### **心智圖增強功能**

1. **連線點擊展開詳情**
```
點擊連線後彈出面板：
┌─────────────────────────┐
│ 連線詳情                 │
│ 192.168.1.1 → 8.8.8.8   │
├─────────────────────────┤
│ 協議: TCP               │
│ 狀態: 已建立             │
│ RTT: 12ms               │
│ 封包數: 523             │
│ 重傳: 2                 │
├─────────────────────────┤
│ [查看完整 PCAP]         │
│ [匯出 IOCs]             │
└─────────────────────────┘
```

2. **時間軸控制**
```
底部時間軸滑桿：
├─────●─────────────────┤
00:00:00      00:00:15    00:00:30

- 拖動可回放歷史
- 暫停/播放/快轉
- 標記異常事件點
```

3. **協議過濾器**
```
右上角過濾面板：
☑ TCP    ☑ UDP
☑ HTTP   ☐ HTTPS
☑ DNS    ☐ ICMP
☑ 顯示異常
```

4. **異常警報視覺化**
```
異常連線特徵：
- 紅色閃爍邊框
- 警告圖示 ⚠️
- 連線加粗
- 節點周圍紅色光暈
- 側邊欄推送通知卡片
```

---

### 四、進階功能規劃

#### **1. 協議統計儀表板**
```
┌─────────────┬─────────────┐
│ TCP: 45%    │ HTTP: 30%   │
├─────────────┼─────────────┤
│ UDP: 15%    │ DNS: 10%    │
└─────────────┴─────────────┘

長條圖顯示：
█████████████░░░░░░░ TCP
███████░░░░░░░░░░░░░ HTTP
████░░░░░░░░░░░░░░░░ UDP
```

#### **2. 異常偵測規則**
```javascript
const anomalyRules = {
  'syn-flood': {
    condition: 'SYN > 100/sec without ACK',
    visual: 'red-pulse',
    alert: '可能的 SYN Flood 攻擊'
  },
  'dns-tunneling': {
    condition: 'DNS queries > 50/min to single domain',
    visual: 'purple-warning',
    alert: '可疑的 DNS 隧道'
  },
  'port-scan': {
    condition: 'Multiple ports from single IP in 10sec',
    visual: 'orange-spread',
    alert: '端口掃描偵測'
  }
};
```

#### **3. 3D 模式（可選）**
```
使用 Three.js 呈現：
- Z 軸代表時間
- 協議用不同高度的層
- 可旋轉視角
- 粒子效果更豐富
```

---

### 五、實作優先順序

**Phase 1 - 基礎協議（2週）**
- ✅ TCP 三次握手
- ✅ TCP 斷線
- ✅ HTTP 請求/回應
- ✅ 超時處理

**Phase 2 - 擴充協議（2週）**
- DNS 查詢
- UDP 傳輸
- ICMP Ping
- TLS/SSL 握手

**Phase 3 - 異常偵測（1週）**
- SYN Flood
- DNS 異常
- 端口掃描
- 異常流量

**Phase 4 - 進階功能（2週）**
- 時間軸回放
- PCAP 匯入
- 詳細統計
- 報告匯出

---

### 六、技術建議

**前端框架選擇：**
- React + D3.js（複雜圖表）
- React + Three.js（3D 視覺化）
- React + Recharts（統計圖表）

**狀態管理：**
- Zustand 或 Redux（管理複雜協議狀態）

**PCAP 解析：**
- 後端：Python (Scapy) / Go (gopacket)
- WebAssembly：編譯 C 的 libpcap

**即時更新：**
- WebSocket 推送即時封包
- Server-Sent Events（SSE）
