# Backend Alignment Notes

## API additions
- `GET /api/timelines`
  - Response: Timeline fixture generated by `scripts/export_protocol_timeline_sample.py`.
  - Schema: `{ sourceFiles: string[], generatedAt: string, timelines: ProtocolTimeline[] }`.
  - `ProtocolTimeline` mirrors the frontend contract (`id`, `protocol`, `startEpochMs`, `endEpochMs`, `stages`, `metrics`).
  - Error: Returns `404` with `detail = "No timeline data available"` when the fixture is missing.

## Connections data contract
- `/api/analysis` already returns `basic_stats.top_connections` with entries shaped as `{ protocol, src_ip, src_port, dst_ip, dst_port, packet_count }`.
- Frontend derives UI labels with `protocolStates` and expects ports to be numeric (nullable when not available).
- Server should keep `top_connections` sorted by packet count and cap to 500 entries to match current behavior in `NetworkAnalyzer`.

## Fixture workflow
1. Analysts capture new PCAP files.
2. Run `python scripts/export_protocol_timeline_sample.py`.
3. Script writes fixtures to both `docs/` (reference) and `public/data/` (served statically) so `/api/timelines` reflects the latest capture once the FastAPI service reloads.

## Open questions for backend team
- Can `NetworkAnalyzer` emit timeline segments directly (so fixture generation becomes part of analysis pipeline)?
- Should `/api/analysis` embed a lightweight `connections` array alongside `basic_stats.top_connections` for quicker frontend access?
- Do we need auth/tenant scoping for `/api/timelines`, or is serving shared fixtures acceptable for the prototype stage?
