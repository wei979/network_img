{
  "url": "https://fastapi.tiangolo.com/advanced/openapi-callbacks/",
  "title": "OpenAPI Callbacks¶",
  "content": "You could create an API with a path operation that could trigger a request to an external API created by someone else (probably the same developer that would be using your API).\n\nThe process that happens when your API app calls the external API is named a \"callback\". Because the software that the external developer wrote sends a request to your API and then your API calls back, sending a request to an external API (that was probably created by the same developer).\n\nIn this case, you could want to document how that external API should look like. What path operation it should have, what body it should expect, what response it should return, etc.\n\nLet's see all this with an example.\n\nImagine you develop an app that allows creating invoices.\n\nThese invoices will have an id, title (optional), customer, and total.\n\nThe user of your API (an external developer) will create an invoice in your API with a POST request.\n\nThen your API will (let's imagine):\n\nLet's first see how the normal API app would look like before adding the callback.\n\nIt will have a path operation that will receive an Invoice body, and a query parameter callback_url that will contain the URL for the callback.\n\nThis part is pretty normal, most of the code is probably already familiar to you:\n\nThe callback_url query parameter uses a Pydantic Url type.\n\nThe only new thing is the callbacks=invoices_callback_router.routes as an argument to the path operation decorator. We'll see what that is next.\n\nThe actual callback code will depend heavily on your own API app.\n\nAnd it will probably vary a lot from one app to the next.\n\nIt could be just one or two lines of code, like:\n\nBut possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc.\n\nSo, what we will do next is add the code to document how that external API should look like to receive the callback from your API.\n\nThat documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API.\n\nThis example doesn't implement the callback itself (that could be just a line of code), only the documentation part.\n\nThe actual callback is just an HTTP request.\n\nWhen implementing the callback yourself, you could use something like HTTPX or Requests.\n\nThis code won't be executed in your app, we only need it to document how that external API should look like.\n\nBut, you already know how to easily create automatic documentation for an API with FastAPI.\n\nSo we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call).\n\nWhen writing the code to document a callback, it might be useful to imagine that you are that external developer. And that you are currently implementing the external API, not your API.\n\nTemporarily adopting this point of view (of the external developer) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API.\n\nFirst create a new APIRouter that will contain one or more callbacks.\n\nTo create the callback path operation use the same APIRouter you created above.\n\nIt should look just like a normal FastAPI path operation:\n\nThere are 2 main differences from a normal path operation:\n\nThe callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API.\n\nIn this case, it's the str:\n\nSo, if your API user (the external developer) sends a request to your API to:\n\nthen your API will process the invoice, and at some point later, send a callback request to the callback_url (the external API):\n\nwith a JSON body containing something like:\n\nand it would expect a response from that external API with a JSON body like:\n\nNotice how the callback URL used contains the URL received as a query parameter in callback_url (https://www.external.org/events) and also the invoice id from inside of the JSON body (2expen51ve).\n\nAt this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API) in the callback router you created above.\n\nNow use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/path operations) from that callback router:\n\nNotice that you are not passing the router itself (invoices_callback_router) to callback=, but the attribute .routes, as in invoices_callback_router.routes.\n\nNow you can start your app and go to http://127.0.0.1:8000/docs.\n\nYou will see your docs including a \"Callbacks\" section for your path operation that shows how the external API should look like:",
  "headings": [
    {
      "level": "h1",
      "text": "OpenAPI Callbacks¶",
      "id": "openapi-callbacks"
    },
    {
      "level": "h2",
      "text": "An app with callbacks¶",
      "id": "an-app-with-callbacks"
    },
    {
      "level": "h2",
      "text": "The normal FastAPI app¶",
      "id": "the-normal-fastapi-app"
    },
    {
      "level": "h2",
      "text": "Documenting the callback¶",
      "id": "documenting-the-callback"
    },
    {
      "level": "h2",
      "text": "Write the callback documentation code¶",
      "id": "write-the-callback-documentation-code"
    },
    {
      "level": "h3",
      "text": "Create a callback APIRouter¶",
      "id": "create-a-callback-apirouter"
    },
    {
      "level": "h3",
      "text": "Create the callback path operation¶",
      "id": "create-the-callback-path-operation"
    },
    {
      "level": "h3",
      "text": "The callback path expression¶",
      "id": "the-callback-path-expression"
    },
    {
      "level": "h3",
      "text": "Add the callback router¶",
      "id": "add-the-callback-router"
    },
    {
      "level": "h3",
      "text": "Check the docs¶",
      "id": "check-the-docs"
    }
  ],
  "code_samples": [
    {
      "code": "from typing import Union\n\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Invoice(BaseModel):\n    id: str\n    title: Union[str, None] = None\n    customer: str\n    total: float\n\n\nclass InvoiceEvent(BaseModel):\n    description: str\n    paid: bool\n\n\nclass InvoiceEventReceived(BaseModel):\n    ok: bool\n\n\ninvoices_callback_router = APIRouter()\n\n\n@invoices_callback_router.post(\n    \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived\n)\ndef invoice_notification(body: InvoiceEvent):\n    pass\n\n\n@app.post(\"/invoices/\", callbacks=invoices_callback_router.routes)\ndef create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}",
      "language": "python"
    },
    {
      "code": "callback_url = \"https://example.com/api/v1/invoices/events/\"\nhttpx.post(callback_url, json={\"description\": \"Invoice paid\", \"paid\": True})",
      "language": "unknown"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Invoice(BaseModel):\n    id: str\n    title: Union[str, None] = None\n    customer: str\n    total: float\n\n\nclass InvoiceEvent(BaseModel):\n    description: str\n    paid: bool\n\n\nclass InvoiceEventReceived(BaseModel):\n    ok: bool\n\n\ninvoices_callback_router = APIRouter()\n\n\n@invoices_callback_router.post(\n    \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived\n)\ndef invoice_notification(body: InvoiceEvent):\n    pass\n\n\n@app.post(\"/invoices/\", callbacks=invoices_callback_router.routes)\ndef create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Invoice(BaseModel):\n    id: str\n    title: Union[str, None] = None\n    customer: str\n    total: float\n\n\nclass InvoiceEvent(BaseModel):\n    description: str\n    paid: bool\n\n\nclass InvoiceEventReceived(BaseModel):\n    ok: bool\n\n\ninvoices_callback_router = APIRouter()\n\n\n@invoices_callback_router.post(\n    \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived\n)\ndef invoice_notification(body: InvoiceEvent):\n    pass\n\n\n@app.post(\"/invoices/\", callbacks=invoices_callback_router.routes)\ndef create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}",
      "language": "python"
    },
    {
      "code": "\"{$callback_url}/invoices/{$request.body.id}\"",
      "language": "unknown"
    },
    {
      "code": "https://yourapi.com/invoices/?callback_url=https://www.external.org/events",
      "language": "unknown"
    },
    {
      "code": "{\n    \"id\": \"2expen51ve\",\n    \"customer\": \"Mr. Richie Rich\",\n    \"total\": \"9999\"\n}",
      "language": "unknown"
    },
    {
      "code": "https://www.external.org/events/invoices/2expen51ve",
      "language": "unknown"
    },
    {
      "code": "{\n    \"description\": \"Payment celebration\",\n    \"paid\": true\n}",
      "language": "unknown"
    },
    {
      "code": "{\n    \"ok\": true\n}",
      "language": "unknown"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Invoice(BaseModel):\n    id: str\n    title: Union[str, None] = None\n    customer: str\n    total: float\n\n\nclass InvoiceEvent(BaseModel):\n    description: str\n    paid: bool\n\n\nclass InvoiceEventReceived(BaseModel):\n    ok: bool\n\n\ninvoices_callback_router = APIRouter()\n\n\n@invoices_callback_router.post(\n    \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived\n)\ndef invoice_notification(body: InvoiceEvent):\n    pass\n\n\n@app.post(\"/invoices/\", callbacks=invoices_callback_router.routes)\ndef create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/advanced/openapi-callbacks/"
  ]
}