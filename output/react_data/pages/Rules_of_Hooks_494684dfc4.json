{
  "url": "https://react.dev/reference/rules/rules-of-hooks",
  "title": "Rules of Hooks",
  "content": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\n\nFunctions whose names start with use are called Hooks in React.\n\nDon‚Äôt call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:\n\nIt‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example:\n\nIf you break these rules, you might see this error.\n\nYou can use the eslint-plugin-react-hooks plugin to catch these mistakes.\n\nCustom Hooks may call other Hooks (that‚Äôs their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering.\n\nDon‚Äôt call Hooks from regular JavaScript functions. Instead, you can:\n\n‚úÖ Call Hooks from React function components. ‚úÖ Call Hooks from custom Hooks.\n\nBy following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.",
  "headings": [
    {
      "level": "h1",
      "text": "Rules of Hooks",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Only call Hooks at the top level",
      "id": "only-call-hooks-at-the-top-level"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Only call Hooks from React functions",
      "id": "only-call-hooks-from-react-functions"
    }
  ],
  "code_samples": [
    {
      "code": "function Counter() {  // ‚úÖ Good: top-level in a function component  const [count, setCount] = useState(0);  // ...}function useWindowWidth() {  // ‚úÖ Good: top-level in a custom Hook  const [width, setWidth] = useState(window.innerWidth);  // ...}",
      "language": "javascript"
    },
    {
      "code": "function Bad({ cond }) {  if (cond) {    // üî¥ Bad: inside a condition (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  for (let i = 0; i < 10; i++) {    // üî¥ Bad: inside a loop (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad({ cond }) {  if (cond) {    return;  }  // üî¥ Bad: after a conditional return (to fix, move it before the return!)  const theme = useContext(ThemeContext);  // ...}function Bad() {  function handleClick() {    // üî¥ Bad: inside an event handler (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  const style = useMemo(() => {    // üî¥ Bad: inside useMemo (to fix, move it outside!)    const theme = useContext(ThemeContext);    return createStyle(theme);  });  // ...}class Bad extends React.Component {  render() {    // üî¥ Bad: inside a class component (to fix, write a function component instead of a class!)    useEffect(() => {})    // ...  }}function Bad() {  try {    // üî¥ Bad: inside try/catch/finally block (to fix, move it outside!)    const [x, setX] = useState(0);  } catch {    const [x, setX] = useState(1);  }}",
      "language": "javascript"
    },
    {
      "code": "function FriendList() {  const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ‚úÖ}function setOnlineStatus() { // ‚ùå Not a component or custom Hook!  const [onlineStatus, setOnlineStatus] = useOnlineStatus();}",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceOverviewRules of HooksHooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. Only call Hooks at the top level Only call Hooks from React functions Only call Hooks at the top level Functions whose names start with use are called Hooks in React. Don‚Äôt call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component: ‚úÖ Call them at the top level in the body of a function component. ‚úÖ Call them at the top level in the body of a custom Hook. function Counter() { // ‚úÖ Good: top-level in a function component const [count, setCount] = useState(0); // ...}function useWindowWidth() { // ‚úÖ Good: top-level in a custom Hook const [width, setWidth] = useState(window.innerWidth); // ...} It‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example: üî¥ Do not call Hooks inside conditions or loops. üî¥ Do not call Hooks after a conditional return statement. üî¥ Do not call Hooks in event handlers. üî¥ Do not call Hooks in class components. üî¥ Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect. üî¥ Do not call Hooks inside try/catch/finally blocks. If you break these rules, you might see this error. function Bad({ cond }) { if (cond) { // üî¥ Bad: inside a condition (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { for (let i = 0; i < 10; i++) { // üî¥ Bad: inside a loop (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad({ cond }) { if (cond) { return; } // üî¥ Bad: after a conditional return (to fix, move it before the return!) const theme = useContext(ThemeContext); // ...}function Bad() { function handleClick() { // üî¥ Bad: inside an event handler (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { const style = useMemo(() => { // üî¥ Bad: inside useMemo (to fix, move it outside!) const theme = useContext(ThemeContext); return createStyle(theme); }); // ...}class Bad extends React.Component { render() { // üî¥ Bad: inside a class component (to fix, write a function component instead of a class!) useEffect(() => {}) // ... }}function Bad() { try { // üî¥ Bad: inside try/catch/finally block (to fix, move it outside!) const [x, setX] = useState(0); } catch { const [x, setX] = useState(1); }} You can use the eslint-plugin-react-hooks plugin to catch these mistakes. NoteCustom Hooks may call other Hooks (that‚Äôs their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering. Only call Hooks from React functions Don‚Äôt call Hooks from regular JavaScript functions. Instead, you can: ‚úÖ Call Hooks from React function components. ‚úÖ Call Hooks from custom Hooks. By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code. function FriendList() { const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ‚úÖ}function setOnlineStatus() { // ‚ùå Not a component or custom Hook! const [onlineStatus, setOnlineStatus] = useOnlineStatus();}PreviousReact calls Components and Hooks",
      "code": "use"
    },
    {
      "description": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. Only call Hooks at the top level Only call Hooks from React functions Only call Hooks at the top level Functions whose names start with use are called Hooks in React. Don‚Äôt call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component: ‚úÖ Call them at the top level in the body of a function component. ‚úÖ Call them at the top level in the body of a custom Hook. function Counter() { // ‚úÖ Good: top-level in a function component const [count, setCount] = useState(0); // ...}function useWindowWidth() { // ‚úÖ Good: top-level in a custom Hook const [width, setWidth] = useState(window.innerWidth); // ...} It‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example: üî¥ Do not call Hooks inside conditions or loops. üî¥ Do not call Hooks after a conditional return statement. üî¥ Do not call Hooks in event handlers. üî¥ Do not call Hooks in class components. üî¥ Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect. üî¥ Do not call Hooks inside try/catch/finally blocks. If you break these rules, you might see this error. function Bad({ cond }) { if (cond) { // üî¥ Bad: inside a condition (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { for (let i = 0; i < 10; i++) { // üî¥ Bad: inside a loop (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad({ cond }) { if (cond) { return; } // üî¥ Bad: after a conditional return (to fix, move it before the return!) const theme = useContext(ThemeContext); // ...}function Bad() { function handleClick() { // üî¥ Bad: inside an event handler (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { const style = useMemo(() => { // üî¥ Bad: inside useMemo (to fix, move it outside!) const theme = useContext(ThemeContext); return createStyle(theme); }); // ...}class Bad extends React.Component { render() { // üî¥ Bad: inside a class component (to fix, write a function component instead of a class!) useEffect(() => {}) // ... }}function Bad() { try { // üî¥ Bad: inside try/catch/finally block (to fix, move it outside!) const [x, setX] = useState(0); } catch { const [x, setX] = useState(1); }} You can use the eslint-plugin-react-hooks plugin to catch these mistakes. NoteCustom Hooks may call other Hooks (that‚Äôs their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering. Only call Hooks from React functions Don‚Äôt call Hooks from regular JavaScript functions. Instead, you can: ‚úÖ Call Hooks from React function components. ‚úÖ Call Hooks from custom Hooks. By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code. function FriendList() { const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ‚úÖ}function setOnlineStatus() { // ‚ùå Not a component or custom Hook! const [onlineStatus, setOnlineStatus] = useOnlineStatus();}PreviousReact calls Components and Hooks",
      "code": "use"
    },
    {
      "description": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. Only call Hooks at the top level Only call Hooks from React functions Only call Hooks at the top level Functions whose names start with use are called Hooks in React. Don‚Äôt call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component: ‚úÖ Call them at the top level in the body of a function component. ‚úÖ Call them at the top level in the body of a custom Hook. function Counter() { // ‚úÖ Good: top-level in a function component const [count, setCount] = useState(0); // ...}function useWindowWidth() { // ‚úÖ Good: top-level in a custom Hook const [width, setWidth] = useState(window.innerWidth); // ...} It‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example: üî¥ Do not call Hooks inside conditions or loops. üî¥ Do not call Hooks after a conditional return statement. üî¥ Do not call Hooks in event handlers. üî¥ Do not call Hooks in class components. üî¥ Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect. üî¥ Do not call Hooks inside try/catch/finally blocks. If you break these rules, you might see this error. function Bad({ cond }) { if (cond) { // üî¥ Bad: inside a condition (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { for (let i = 0; i < 10; i++) { // üî¥ Bad: inside a loop (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad({ cond }) { if (cond) { return; } // üî¥ Bad: after a conditional return (to fix, move it before the return!) const theme = useContext(ThemeContext); // ...}function Bad() { function handleClick() { // üî¥ Bad: inside an event handler (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { const style = useMemo(() => { // üî¥ Bad: inside useMemo (to fix, move it outside!) const theme = useContext(ThemeContext); return createStyle(theme); }); // ...}class Bad extends React.Component { render() { // üî¥ Bad: inside a class component (to fix, write a function component instead of a class!) useEffect(() => {}) // ... }}function Bad() { try { // üî¥ Bad: inside try/catch/finally block (to fix, move it outside!) const [x, setX] = useState(0); } catch { const [x, setX] = useState(1); }} You can use the eslint-plugin-react-hooks plugin to catch these mistakes. NoteCustom Hooks may call other Hooks (that‚Äôs their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering. Only call Hooks from React functions Don‚Äôt call Hooks from regular JavaScript functions. Instead, you can: ‚úÖ Call Hooks from React function components. ‚úÖ Call Hooks from custom Hooks. By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code. function FriendList() { const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ‚úÖ}function setOnlineStatus() { // ‚ùå Not a component or custom Hook! const [onlineStatus, setOnlineStatus] = useOnlineStatus();}",
      "code": "use"
    },
    {
      "description": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. Only call Hooks at the top level Only call Hooks from React functions Only call Hooks at the top level Functions whose names start with use are called Hooks in React. Don‚Äôt call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component: ‚úÖ Call them at the top level in the body of a function component. ‚úÖ Call them at the top level in the body of a custom Hook. function Counter() { // ‚úÖ Good: top-level in a function component const [count, setCount] = useState(0); // ...}function useWindowWidth() { // ‚úÖ Good: top-level in a custom Hook const [width, setWidth] = useState(window.innerWidth); // ...} It‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example: üî¥ Do not call Hooks inside conditions or loops. üî¥ Do not call Hooks after a conditional return statement. üî¥ Do not call Hooks in event handlers. üî¥ Do not call Hooks in class components. üî¥ Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect. üî¥ Do not call Hooks inside try/catch/finally blocks. If you break these rules, you might see this error. function Bad({ cond }) { if (cond) { // üî¥ Bad: inside a condition (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { for (let i = 0; i < 10; i++) { // üî¥ Bad: inside a loop (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad({ cond }) { if (cond) { return; } // üî¥ Bad: after a conditional return (to fix, move it before the return!) const theme = useContext(ThemeContext); // ...}function Bad() { function handleClick() { // üî¥ Bad: inside an event handler (to fix, move it outside!) const theme = useContext(ThemeContext); } // ...}function Bad() { const style = useMemo(() => { // üî¥ Bad: inside useMemo (to fix, move it outside!) const theme = useContext(ThemeContext); return createStyle(theme); }); // ...}class Bad extends React.Component { render() { // üî¥ Bad: inside a class component (to fix, write a function component instead of a class!) useEffect(() => {}) // ... }}function Bad() { try { // üî¥ Bad: inside try/catch/finally block (to fix, move it outside!) const [x, setX] = useState(0); } catch { const [x, setX] = useState(1); }} You can use the eslint-plugin-react-hooks plugin to catch these mistakes. NoteCustom Hooks may call other Hooks (that‚Äôs their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering. Only call Hooks from React functions Don‚Äôt call Hooks from regular JavaScript functions. Instead, you can: ‚úÖ Call Hooks from React function components. ‚úÖ Call Hooks from custom Hooks. By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code. function FriendList() { const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ‚úÖ}function setOnlineStatus() { // ‚ùå Not a component or custom Hook! const [onlineStatus, setOnlineStatus] = useOnlineStatus();}",
      "code": "use"
    },
    {
      "description": "It‚Äôs not supported to call Hooks (functions starting with use) in any other cases, for example:",
      "code": "use"
    }
  ],
  "links": [
    "https://react.dev/reference/react",
    "https://react.dev/reference/rules",
    "https://react.dev/reference/rules/rules-of-hooks",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/rules/react-calls-components-and-hooks"
  ]
}