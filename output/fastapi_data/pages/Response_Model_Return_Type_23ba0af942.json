{
  "url": "https://fastapi.tiangolo.com/tutorial/response-model/",
  "title": "Response Model - Return TypeÂ¶",
  "content": "You can declare the type used for the response by annotating the path operation function return type.\n\nYou can use type annotations the same way you would for input data in function parameters, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.\n\nFastAPI will use this return type to:\n\nBut most importantly:\n\nThere are some cases where you need or want to return some data that is not exactly what the type declares.\n\nFor example, you could want to return a dictionary or a database object, but declare it as a Pydantic model. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).\n\nIf you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).\n\nIn those cases, you can use the path operation decorator parameter response_model instead of the return type.\n\nYou can use the response_model parameter in any of the path operations:\n\nNotice that response_model is a parameter of the \"decorator\" method (get, post, etc). Not of your path operation function, like all the parameters and body.\n\nresponse_model receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a list of Pydantic models, like List[Item].\n\nFastAPI will use this response_model to do all the data documentation, validation, etc. and also to convert and filter the output data to its type declaration.\n\nIf you have strict type checks in your editor, mypy, etc, you can declare the function return type as Any.\n\nThat way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the response_model.\n\nIf you declare both a return type and a response_model, the response_model will take priority and be used by FastAPI.\n\nThis way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the response_model.\n\nYou can also use response_model=None to disable creating a response model for that path operation, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.\n\nHere we are declaring a UserIn model, it will contain a plaintext password:\n\nTo use EmailStr, first install email-validator.\n\nMake sure you create a virtual environment, activate it, and then install it, for example:\n\nAnd we are using this model to declare our input and the same model to declare our output:\n\nNow, whenever a browser is creating a user with a password, the API will return the same password in the response.\n\nIn this case, it might not be a problem, because it's the same user sending the password.\n\nBut if we use the same model for another path operation, we could be sending our user's passwords to every client.\n\nNever store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.\n\nWe can instead create an input model with the plaintext password and an output model without it:\n\nHere, even though our path operation function is returning the same input user that contains the password:\n\n...we declared the response_model to be our model UserOut, that doesn't include the password:\n\nSo, FastAPI will take care of filtering out all the data that is not declared in the output model (using Pydantic).\n\nIn this case, because the two models are different, if we annotated the function return type as UserOut, the editor and tools would complain that we are returning an invalid type, as those are different classes.\n\nThat's why in this example we have to declare it in the response_model parameter.\n\n...but continue reading below to see how to overcome that.\n\nLet's continue from the previous example. We wanted to annotate the function with one type, but we wanted to be able to return from the function something that actually includes more data.\n\nWe want FastAPI to keep filtering the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.\n\nIn the previous example, because the classes were different, we had to use the response_model parameter. But that also means that we don't get the support from the editor and tools checking the function return type.\n\nBut in most of the cases where we need to do something like this, we want the model just to filter/remove some of the data as in this example.\n\nAnd in those cases, we can use classes and inheritance to take advantage of function type annotations to get better support in the editor and tools, and still get the FastAPI data filtering.\n\nWith this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.\n\nHow does this work? Let's check that out. ðŸ¤“\n\nFirst let's see how editors, mypy and other tools would see this.\n\nBaseUser has the base fields. Then UserIn inherits from BaseUser and adds the password field, so, it will include all the fields from both models.\n\nWe annotate the function return type as BaseUser, but we are actually returning a UserIn instance.\n\nThe editor, mypy, and other tools won't complain about this because, in typing terms, UserIn is a subclass of BaseUser, which means it's a valid type when what is expected is anything that is a BaseUser.\n\nNow, for FastAPI, it will see the return type and make sure that what you return includes only the fields that are declared in the type.\n\nFastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.\n\nThis way, you can get the best of both worlds: type annotations with tooling support and data filtering.\n\nWhen you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:\n\nAnd both models will be used for the interactive API documentation:\n\nThere might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).\n\nThe most common case would be returning a Response directly as explained later in the advanced docs.\n\nThis simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of) Response.\n\nAnd tools will also be happy because both RedirectResponse and JSONResponse are subclasses of Response, so the type annotation is correct.\n\nYou can also use a subclass of Response in the type annotation:\n\nThis will also work because RedirectResponse is a subclass of Response, and FastAPI will automatically handle this simple case.\n\nBut when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.\n\nThe same would happen if you had something like a union between different types where one or more of them are not valid Pydantic types, for example this would fail ðŸ’¥:\n\n...this fails because the type annotation is not a Pydantic type and is not just a single Response class or subclass, it's a union (any of the two) between a Response and a dict.\n\nContinuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.\n\nBut you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).\n\nIn this case, you can disable the response model generation by setting response_model=None:\n\nThis will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ðŸ¤“\n\nYour response model could have default values, like:\n\nbut you might want to omit them from the result if they were not actually stored.\n\nFor example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.\n\nYou can set the path operation decorator parameter response_model_exclude_unset=True:\n\nand those default values won't be included in the response, only the values actually set.\n\nSo, if you send a request to that path operation for the item with ID foo, the response (not including default values) will be:\n\nIn Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().\n\nThe examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.\n\nFastAPI uses Pydantic model's .dict() with its exclude_unset parameter to achieve this.\n\nas described in the Pydantic docs for exclude_defaults and exclude_none.\n\nBut if your data has values for the model's fields with default values, like the item with ID bar:\n\nthey will be included in the response.\n\nIf the data has the same values as the default ones, like the item with ID baz:\n\nFastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though description, tax, and tags have the same values as the defaults, they were set explicitly (instead of taken from the defaults).\n\nSo, they will be included in the JSON response.\n\nNotice that the default values can be anything, not only None.\n\nThey can be a list ([]), a float of 10.5, etc.\n\nYou can also use the path operation decorator parameters response_model_include and response_model_exclude.\n\nThey take a set of str with the name of the attributes to include (omitting the rest) or to exclude (including the rest).\n\nThis can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.\n\nBut it is still recommended to use the ideas above, using multiple classes, instead of these parameters.\n\nThis is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use response_model_include or response_model_exclude to omit some attributes.\n\nThis also applies to response_model_by_alias that works similarly.\n\nThe syntax {\"name\", \"description\"} creates a set with those two values.\n\nIt is equivalent to set([\"name\", \"description\"]).\n\nIf you forget to use a set and use a list or tuple instead, FastAPI will still convert it to a set and it will work correctly:\n\nUse the path operation decorator's parameter response_model to define response models and especially to ensure private data is filtered out.\n\nUse response_model_exclude_unset to return only the values explicitly set.",
  "headings": [
    {
      "level": "h1",
      "text": "Response Model - Return TypeÂ¶",
      "id": "response-model-return-type"
    },
    {
      "level": "h2",
      "text": "response_model ParameterÂ¶",
      "id": "response-model-parameter"
    },
    {
      "level": "h3",
      "text": "response_model PriorityÂ¶",
      "id": "response-model-priority"
    },
    {
      "level": "h2",
      "text": "Return the same input dataÂ¶",
      "id": "return-the-same-input-data"
    },
    {
      "level": "h2",
      "text": "Add an output modelÂ¶",
      "id": "add-an-output-model"
    },
    {
      "level": "h3",
      "text": "response_model or Return TypeÂ¶",
      "id": "response-model-or-return-type"
    },
    {
      "level": "h2",
      "text": "Return Type and Data FilteringÂ¶",
      "id": "return-type-and-data-filtering"
    },
    {
      "level": "h3",
      "text": "Type Annotations and ToolingÂ¶",
      "id": "type-annotations-and-tooling"
    },
    {
      "level": "h3",
      "text": "FastAPI Data FilteringÂ¶",
      "id": "fastapi-data-filtering"
    },
    {
      "level": "h2",
      "text": "See it in the docsÂ¶",
      "id": "see-it-in-the-docs"
    },
    {
      "level": "h2",
      "text": "Other Return Type AnnotationsÂ¶",
      "id": "other-return-type-annotations"
    },
    {
      "level": "h3",
      "text": "Return a Response DirectlyÂ¶",
      "id": "return-a-response-directly"
    },
    {
      "level": "h3",
      "text": "Annotate a Response SubclassÂ¶",
      "id": "annotate-a-response-subclass"
    },
    {
      "level": "h3",
      "text": "Invalid Return Type AnnotationsÂ¶",
      "id": "invalid-return-type-annotations"
    },
    {
      "level": "h3",
      "text": "Disable Response ModelÂ¶",
      "id": "disable-response-model"
    },
    {
      "level": "h2",
      "text": "Response Model encoding parametersÂ¶",
      "id": "response-model-encoding-parameters"
    },
    {
      "level": "h3",
      "text": "Use the response_model_exclude_unset parameterÂ¶",
      "id": "use-the-response-model-exclude-unset-parameter"
    },
    {
      "level": "h4",
      "text": "Data with values for fields with defaultsÂ¶",
      "id": "data-with-values-for-fields-with-defaults"
    },
    {
      "level": "h4",
      "text": "Data with the same values as the defaultsÂ¶",
      "id": "data-with-the-same-values-as-the-defaults"
    },
    {
      "level": "h3",
      "text": "response_model_include and response_model_excludeÂ¶",
      "id": "response-model-include-and-response-model-exclude"
    },
    {
      "level": "h4",
      "text": "Using lists instead of setsÂ¶",
      "id": "using-lists-instead-of-sets"
    },
    {
      "level": "h2",
      "text": "RecapÂ¶",
      "id": "recap"
    }
  ],
  "code_samples": [
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list[str] = []\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item) -> Item:\n    return item\n\n\n@app.get(\"/items/\")\nasync def read_items() -> list[Item]:\n    return [\n        Item(name=\"Portal Gun\", price=42.0),\n        Item(name=\"Plumbus\", price=32.0),\n    ]",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: list[str] = []\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item) -> Item:\n    return item\n\n\n@app.get(\"/items/\")\nasync def read_items() -> list[Item]:\n    return [\n        Item(name=\"Portal Gun\", price=42.0),\n        Item(name=\"Plumbus\", price=32.0),\n    ]",
      "language": "python"
    },
    {
      "code": "from typing import List, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: List[str] = []\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item) -> Item:\n    return item\n\n\n@app.get(\"/items/\")\nasync def read_items() -> List[Item]:\n    return [\n        Item(name=\"Portal Gun\", price=42.0),\n        Item(name=\"Plumbus\", price=32.0),\n    ]",
      "language": "python"
    },
    {
      "code": "from typing import Any\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list[str] = []\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item) -> Any:\n    return item\n\n\n@app.get(\"/items/\", response_model=list[Item])\nasync def read_items() -> Any:\n    return [\n        {\"name\": \"Portal Gun\", \"price\": 42.0},\n        {\"name\": \"Plumbus\", \"price\": 32.0},\n    ]",
      "language": "python"
    },
    {
      "code": "from typing import Any, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: list[str] = []\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item) -> Any:\n    return item\n\n\n@app.get(\"/items/\", response_model=list[Item])\nasync def read_items() -> Any:\n    return [\n        {\"name\": \"Portal Gun\", \"price\": 42.0},\n        {\"name\": \"Plumbus\", \"price\": 32.0},\n    ]",
      "language": "python"
    },
    {
      "code": "from typing import Any, List, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: List[str] = []\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item) -> Any:\n    return item\n\n\n@app.get(\"/items/\", response_model=List[Item])\nasync def read_items() -> Any:\n    return [\n        {\"name\": \"Portal Gun\", \"price\": 42.0},\n        {\"name\": \"Plumbus\", \"price\": 32.0},\n    ]",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\n# Don't do this in production!\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> UserIn:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\n# Don't do this in production!\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> UserIn:\n    return user",
      "language": "python"
    },
    {
      "code": "$ pip install email-validator",
      "language": "unknown"
    },
    {
      "code": "$ pip install \"pydantic[email]\"",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\n# Don't do this in production!\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> UserIn:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\n# Don't do this in production!\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> UserIn:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Any, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\n@app.post(\"/user/\", response_model=UserOut)\nasync def create_user(user: UserIn) -> Any:\n    return user",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass BaseUser(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserIn(BaseUser):\n    password: str\n\n\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> BaseUser:\n    return user",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass BaseUser(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: Union[str, None] = None\n\n\nclass UserIn(BaseUser):\n    password: str\n\n\n@app.post(\"/user/\")\nasync def create_user(user: UserIn) -> BaseUser:\n    return user",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, Response\nfrom fastapi.responses import JSONResponse, RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/portal\")\nasync def get_portal(teleport: bool = False) -> Response:\n    if teleport:\n        return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n    return JSONResponse(content={\"message\": \"Here's your interdimensional portal.\"})",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/teleport\")\nasync def get_teleport() -> RedirectResponse:\n    return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, Response\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/portal\")\nasync def get_portal(teleport: bool = False) -> Response | dict:\n    if teleport:\n        return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n    return {\"message\": \"Here's your interdimensional portal.\"}",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI, Response\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/portal\")\nasync def get_portal(teleport: bool = False) -> Union[Response, dict]:\n    if teleport:\n        return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n    return {\"message\": \"Here's your interdimensional portal.\"}",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI, Response\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/portal\", response_model=None)\nasync def get_portal(teleport: bool = False) -> Response | dict:\n    if teleport:\n        return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n    return {\"message\": \"Here's your interdimensional portal.\"}",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI, Response\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\n\n\n@app.get(\"/portal\", response_model=None)\nasync def get_portal(teleport: bool = False) -> Union[Response, dict]:\n    if teleport:\n        return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n    return {\"message\": \"Here's your interdimensional portal.\"}",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float = 10.5\n    tags: list[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n    tags: list[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import List, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n    tags: List[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float = 10.5\n    tags: list[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n    tags: list[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import List, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n    tags: List[str] = []\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": []},\n}\n\n\n@app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True)\nasync def read_item(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "{\n    \"name\": \"Foo\",\n    \"price\": 50.2\n}",
      "language": "unknown"
    },
    {
      "code": "{\n    \"name\": \"Bar\",\n    \"description\": \"The bartenders\",\n    \"price\": 62,\n    \"tax\": 20.2\n}",
      "language": "unknown"
    },
    {
      "code": "{\n    \"name\": \"Baz\",\n    \"description\": None,\n    \"price\": 50.2,\n    \"tax\": 10.5,\n    \"tags\": []\n}",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float = 10.5\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\n        \"name\": \"Baz\",\n        \"description\": \"There goes my baz\",\n        \"price\": 50.2,\n        \"tax\": 10.5,\n    },\n}\n\n\n@app.get(\n    \"/items/{item_id}/name\",\n    response_model=Item,\n    response_model_include={\"name\", \"description\"},\n)\nasync def read_item_name(item_id: str):\n    return items[item_id]\n\n\n@app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude={\"tax\"})\nasync def read_item_public_data(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\n        \"name\": \"Baz\",\n        \"description\": \"There goes my baz\",\n        \"price\": 50.2,\n        \"tax\": 10.5,\n    },\n}\n\n\n@app.get(\n    \"/items/{item_id}/name\",\n    response_model=Item,\n    response_model_include={\"name\", \"description\"},\n)\nasync def read_item_name(item_id: str):\n    return items[item_id]\n\n\n@app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude={\"tax\"})\nasync def read_item_public_data(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float = 10.5\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\n        \"name\": \"Baz\",\n        \"description\": \"There goes my baz\",\n        \"price\": 50.2,\n        \"tax\": 10.5,\n    },\n}\n\n\n@app.get(\n    \"/items/{item_id}/name\",\n    response_model=Item,\n    response_model_include=[\"name\", \"description\"],\n)\nasync def read_item_name(item_id: str):\n    return items[item_id]\n\n\n@app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude=[\"tax\"])\nasync def read_item_public_data(item_id: str):\n    return items[item_id]",
      "language": "python"
    },
    {
      "code": "from typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: float = 10.5\n\n\nitems = {\n    \"foo\": {\"name\": \"Foo\", \"price\": 50.2},\n    \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2},\n    \"baz\": {\n        \"name\": \"Baz\",\n        \"description\": \"There goes my baz\",\n        \"price\": 50.2,\n        \"tax\": 10.5,\n    },\n}\n\n\n@app.get(\n    \"/items/{item_id}/name\",\n    response_model=Item,\n    response_model_include=[\"name\", \"description\"],\n)\nasync def read_item_name(item_id: str):\n    return items[item_id]\n\n\n@app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude=[\"tax\"])\nasync def read_item_public_data(item_id: str):\n    return items[item_id]",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Info To use EmailStr, first install email-validator. Make sure you create a virtual environment, activate it, and then install it, for example: $ pip install email-validator or with: $ pip install \"pydantic[email]\"",
      "code": "EmailStr"
    },
    {
      "description": "Make sure you create a virtual environment, activate it, and then install it, for example:",
      "code": "$ pip install email-validator"
    }
  ],
  "links": [
    "https://fastapi.tiangolo.com/tutorial/response-model/",
    "https://fastapi.tiangolo.com/virtual-environments/",
    "https://fastapi.tiangolo.com/advanced/response-directly/"
  ]
}