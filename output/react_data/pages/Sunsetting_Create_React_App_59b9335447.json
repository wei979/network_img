{
  "url": "https://react.dev/blog/2025/02/14/sunsetting-create-react-app",
  "title": "Sunsetting Create React App",
  "content": "February 14, 2025 by Matt Carroll and Ricky Hanlon\n\nToday, we’re deprecating Create React App for new apps, and encouraging existing apps to migrate to a framework, or to migrate to a build tool like Vite, Parcel, or RSBuild.\n\nWe’re also providing docs for when a framework isn’t a good fit for your project, you want to build your own framework, or you just want to learn how React works by building a React app from scratch.\n\nWhen we released Create React App in 2016, there was no clear way to build a new React app.\n\nTo create a React app, you had to install a bunch of tools and wire them up together yourself to support basic features like JSX, linting, and hot reloading. This was very tricky to do correctly, so the community created boilerplates for common setups. However, boilerplates were difficult to update and fragmentation made it difficult for React to release new features.\n\nCreate React App solved these problems by combining several tools into a single recommended configuration. This allowed apps a simple way to upgrade to new tooling features, and allowed the React team to deploy non-trivial tooling changes (Fast Refresh support, React Hooks lint rules) to the broadest possible audience.\n\nThis model became so popular that there’s an entire category of tools working this way today.\n\nAlthough Create React App makes it easy to get started, there are several limitations that make it difficult to build high performant production apps. In principle, we could solve these problems by essentially evolving it into a framework.\n\nHowever, since Create React App currently has no active maintainers, and there are many existing frameworks that solve these problems already, we’ve decided to deprecate Create React App.\n\nStarting today, if you install a new app, you will see a deprecation warning:\n\nWe’ve also added a deprecation notice to the Create React App website and GitHub repo. Create React App will continue working in maintenance mode, and we’ve published a new version of Create React App to work with React 19.\n\nWe recommend creating new React apps with a framework. All the frameworks we recommend support client-side rendering (CSR) and single-page apps (SPA), and can be deployed to a CDN or static hosting service without a server.\n\nFor existing apps, these guides will help you migrate to a client-only SPA:\n\nIf your app has unusual constraints, or you prefer to solve these problems by building your own framework, or you just want to learn how react works from scratch, you can roll your own custom setup with React using Vite, Parcel or Rsbuild.\n\nFor existing apps, these guides will help you migrate to a build tool:\n\nTo help get started with Vite, Parcel or Rsbuild, we’ve added new docs for Building a React App from Scratch.\n\nMost apps would benefit from a framework, but there are valid cases to build a React app from scratch. A good rule of thumb is if your app needs routing, you would probably benefit from a framework.\n\nJust like Svelte has Sveltekit, Vue has Nuxt, and Solid has SolidStart, React recommends using a framework that fully integrates routing into features like data-fetching and code-splitting out of the box. This avoids the pain of needing to write your own complex configurations and essentially build a framework yourself.\n\nHowever, you can always build a React app from scratch using a build tool like Vite, Parcel, or Rsbuild.\n\nContinue reading to learn more about the limitations of build tools and why we recommend frameworks.\n\nCreate React App and build tools like it make it easy to get started building a React app. After running npx create-react-app my-app, you get a fully configured React app with a development server, linting, and a production build.\n\nFor example, if you’re building an internal admin tool, you can start with a landing page:\n\nThis allows you to immediately start coding in React with features like JSX, default linting rules, and a bundler to run in both development and production. However, this setup is missing the tools you need to build a real production app.\n\nMost production apps need solutions to problems like routing, data fetching, and code splitting.\n\nCreate React App does not include a specific routing solution. If you’re just getting started, one option is to use useState to switch between routes. But doing this means that you can’t share links to your app - every link would go to the same page - and structuring your app becomes difficult over time:\n\nThis is why most apps that use Create React App solve add routing with a routing library like React Router or Tanstack Router. With a routing library, you can add additional routes to the app, which provides opinions on the structure of your app, and allows you to start sharing links to routes. For example, with React Router you can define routes:\n\nWith this change, you can share a link to /dashboard and the app will navigate to the dashboard page . Once you have a routing library, you can add additional features like nested routes, route guards, and route transitions, which are difficult to implement without a routing library.\n\nThere’s a tradeoff being made here: the routing library adds complexity to the app, but it also adds features that are difficult to implement without it.\n\nAnother common problem in Create React App is data fetching. Create React App does not include a specific data fetching solution. If you’re just getting started, a common option is to use fetch in an effect to load data.\n\nBut doing this means that the data is fetched after the component renders, which can cause network waterfalls. Network waterfalls are caused by fetching data when your app renders instead of in parallel while the code is downloading:\n\nFetching in an effect means the user has to wait longer to see the content, even though the data could have been fetched earlier. To solve this, you can use a data fetching library like React Query, SWR, Apollo, or Relay which provide options to prefetch data so the request is started before the component renders.\n\nThese libraries work best when integrated with your routing “loader” pattern to specify data dependencies at the route level, which allows the router to optimize your data fetches:\n\nOn initial load, the router can fetch the data immediately before the route is rendered. As the user navigates around the app, the router is able to fetch both the data and the route at the same time, parallelizing the fetches. This reduces the time it takes to see the content on the screen, and can improve the user experience.\n\nHowever, this requires correctly configuring the loaders in your app and trades off complexity for performance.\n\nAnother common problem in Create React App is code splitting. Create React App does not include a specific code splitting solution. If you’re just getting started, you might not consider code splitting at all.\n\nThis means your app is shipped as a single bundle:\n\nBut for ideal performance, you should “split” your code into separate bundles so the user only needs to download what they need. This decreases the time the user needs to wait to load your app, by only downloading the code they need to see the page they are on.\n\nOne way to do code-splitting is with React.lazy. However, this means that the code is not fetched until the component renders, which can cause network waterfalls. A more optimal solution is to use a router feature that fetches the code in parallel while the code is downloading. For example, React Router provides a lazy option to specify that a route should be code split and optimize when it is loaded:\n\nOptimized code-splitting is tricky to get right, and it’s easy to make mistakes that can cause the user to download more code than they need. It works best when integrated with your router and data loading solutions to maximize caching, parallelize fetches, and support “import on interaction” patterns.\n\nThese are just a few examples of the limitations of Create React App.\n\nOnce you’ve integrated routing, data-fetching, and code splitting, you now also need to consider pending states, navigation interruptions, error messages to the user, and revalidation of the data. There are entire categories of problems that users need to solve like:\n\nAll of these work together to create the most optimal loading sequence.\n\nSolving each of these problems individually in Create React App can be difficult as each problem is interconnected with the others and can require deep expertise in problem areas users may not be familiar with. In order to solve these problems, users end up building their own bespoke solutions on top of Create React App, which was the problem Create React App originally tried to solve.\n\nAlthough you could solve all these pieces yourself in a build tool like Create React App, Vite, or Parcel, it is hard to do well. Just like when Create React App itself integrated several build tools together, you need a tool to integrate all of these features together to provide the best experience to users.\n\nThis category of tools that integrates build tools, rendering, routing, data fetching, and code splitting are known as “frameworks” — or if you prefer to call React itself a framework, you might call them “metaframeworks”.\n\nFrameworks impose some opinions about structuring your app in order to provide a much better user experience, in the same way build tools impose some opinions to make tooling easier. This is why we started recommending frameworks like Next.js, React Router, and Expo for new projects.\n\nFrameworks provide the same getting started experience as Create React App, but also provide solutions to problems users need to solve anyway in real production apps.\n\nThe frameworks we recommend all provide the option to create a client-side rendered (CSR) app.\n\nIn some cases, CSR is the right choice for a page, but many times it’s not. Even if most of your app is client-side, there are often individual pages that could benefit from server rendering features like static-site generation (SSG) or server-side rendering (SSR), for example a Terms of Service page, or documentation.\n\nServer rendering generally sends less JavaScript to the client, and a full HTML document which produces a faster First Contentful Paint (FCP) by reducing Total Blocking Time (TBD), which can also lower Interaction to Next Paint (INP). This is why the Chrome team has encouraged developers to consider static or server-side render over a full client-side approach to achieve the best possible performance.\n\nThere are tradeoffs to using a server, and it is not always the best option for every page. Generating pages on the server incurs additional cost and takes time to generate which can increase Time to First Byte (TTFB). The best performing apps are able to pick the right rendering strategy on a per-page basis, based on the tradeoffs of each strategy.\n\nFrameworks provide the option to use a server on any page if you want to, but do not force you to use a server. This allows you to pick the right rendering strategy for each page in your app.\n\nThe frameworks we recommend also include support for React Server Components.\n\nServer Components help solve these problems by moving routing and data fetching to the server, and allowing code splitting to be done for client components based on the data you render, instead of just the route rendered, and reducing the amount of JavaScript shipped for the best possible loading sequence.\n\nServer Components do not require a server. They can be run at build time on your CI server to create a static-site generated app (SSG) app, at runtime on a web server for a server-side rendered (SSR) app.\n\nSee Introducing zero-bundle size React Server Components and the docs for more info.\n\nA common misunderstanding is that server rendering is only for SEO.\n\nWhile server rendering can improve SEO, it also improves performance by reducing the amount of JavaScript the user needs to download and parse before they can see the content on the screen.\n\nThis is why the Chrome team has encouraged developers to consider static or server-side render over a full client-side approach to achieve the best possible performance.\n\nThank you to Dan Abramov for creating Create React App, and Joe Haddad, Ian Schmitz, Brody McKee, and many others for maintaining Create React App over the years. Thank you to Brooks Lybrand, Dan Abramov, Devon Govett, Eli White, Jack Herrington, Joe Savona, Lauren Tan, Lee Robinson, Mark Erikson, Ryan Florence, Sophie Alpert, Tanner Linsley, and Theo Browne for reviewing and providing feedback on this post.",
  "headings": [
    {
      "level": "h1",
      "text": "Sunsetting Create React App",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Deprecating Create React App",
      "id": "deprecating-create-react-app"
    },
    {
      "level": "h2",
      "text": "How to Migrate to a Framework",
      "id": "how-to-migrate-to-a-framework"
    },
    {
      "level": "h2",
      "text": "How to Migrate to a Build Tool",
      "id": "how-to-migrate-to-a-build-tool"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Do I need a framework?",
      "id": "do-i-need-a-framework"
    },
    {
      "level": "h2",
      "text": "Limitations of Build Tools",
      "id": "limitations-of-build-tools"
    },
    {
      "level": "h3",
      "text": "Routing",
      "id": "routing"
    },
    {
      "level": "h3",
      "text": "Data Fetching",
      "id": "data-fetching"
    },
    {
      "level": "h3",
      "text": "Code Splitting",
      "id": "code-splitting"
    },
    {
      "level": "h3",
      "text": "And more…",
      "id": "and-more"
    },
    {
      "level": "h2",
      "text": "Why we Recommend Frameworks",
      "id": "why-we-recommend-frameworks"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Server rendering is optional",
      "id": "server-rendering-is-optional"
    },
    {
      "level": "h4",
      "text": "What About Server Components",
      "id": "server-components"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Server Rendering is not just for SEO",
      "id": "server-rendering-is-not-just-for-seo"
    }
  ],
  "code_samples": [
    {
      "code": "export default function App() {  return (    <div>      <h1>Welcome to the Admin Tool!</h1>    </div>  )}",
      "language": "unknown"
    },
    {
      "code": "import {useState} from 'react';import Home from './Home';import Dashboard from './Dashboard';export default function App() {  // ❌ Routing in state does not create URLs  const [route, setRoute] = useState('home');  return (    <div>      {route === 'home' && <Home />}      {route === 'dashboard' && <Dashboard />}    </div>  )}",
      "language": "python"
    },
    {
      "code": "import {RouterProvider, createBrowserRouter} from 'react-router';import Home from './Home';import Dashboard from './Dashboard';// ✅ Each route has it's own URLconst router = createBrowserRouter([  {path: '/', element: <Home />},  {path: '/dashboard', element: <Dashboard />}]);export default function App() {  return (    <RouterProvider value={router} />  )}",
      "language": "python"
    },
    {
      "code": "export default function Dashboard() {  const [data, setData] = useState(null);  // ❌ Fetching data in a component causes network waterfalls  useEffect(() => {    fetch('/api/data')      .then(response => response.json())      .then(data => setData(data));  }, []);  return (    <div>      {data.map(item => <div key={item.id}>{item.name}</div>)}    </div>  )}",
      "language": "javascript"
    },
    {
      "code": "export async function loader() {  const response = await fetch(`/api/data`);  const data = await response.json();  return data;}// ✅ Fetching data in parallel while the code is downloadingexport default function Dashboard({loaderData}) {  return (    <div>      {loaderData.map(item => <div key={item.id}>{item.name}</div>)}    </div>  )}",
      "language": "javascript"
    },
    {
      "code": "- bundle.js    75kb",
      "language": "unknown"
    },
    {
      "code": "- core.js      25kb- home.js      25kb- dashboard.js 25kb",
      "language": "unknown"
    },
    {
      "code": "import Home from './Home';import Dashboard from './Dashboard';// ✅ Routes are downloaded before renderingconst router = createBrowserRouter([  {path: '/', lazy: () => import('./Home')},  {path: '/dashboard', lazy: () => import('Dashboard')}]);",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/blog",
    "https://react.dev/blog/2025/02/14/sunsetting-create-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components",
    "https://react.dev/reference/rsc/server-components",
    "https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more",
    "https://react.dev/blog/2024/12/05/react-19"
  ]
}