{
  "url": "https://fastapi.tiangolo.com/advanced/settings/",
  "title": "Settings and Environment Variables¶",
  "content": "In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.\n\nMost of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.\n\nFor this reason it's common to provide them in environment variables that are read by the application.\n\nTo understand environment variables you can read Environment Variables.\n\nThese environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).\n\nThat means that any value read in Python from an environment variable will be a str, and any conversion to a different type or any validation has to be done in code.\n\nFortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management.\n\nFirst, make sure you create your virtual environment, activate it, and then install the pydantic-settings package:\n\nIt also comes included when you install the all extras with:\n\nIn Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.\n\nImport BaseSettings from Pydantic and create a sub-class, very much like with a Pydantic model.\n\nThe same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.\n\nYou can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with Field().\n\nIn Pydantic v1 you would import BaseSettings directly from pydantic instead of from pydantic_settings.\n\nIf you want something quick to copy and paste, don't use this example, use the last one below.\n\nThen, when you create an instance of that Settings class (in this case, in the settings object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable APP_NAME will still be read for the attribute app_name.\n\nNext it will convert and validate the data. So, when you use that settings object, you will have data of the types you declared (e.g. items_per_user will be an int).\n\nThen you can use the new settings object in your application:\n\nNext, you would run the server passing the configurations as environment variables, for example you could set an ADMIN_EMAIL and APP_NAME with:\n\nTo set multiple env vars for a single command just separate them with a space, and put them all before the command.\n\nAnd then the admin_email setting would be set to \"deadpool@example.com\".\n\nThe app_name would be \"ChimichangApp\".\n\nAnd the items_per_user would keep its default value of 50.\n\nYou could put those settings in another module file as you saw in Bigger Applications - Multiple Files.\n\nFor example, you could have a file config.py with:\n\nAnd then use it in a file main.py:\n\nYou would also need a file __init__.py as you saw in Bigger Applications - Multiple Files.\n\nIn some occasions it might be useful to provide the settings from a dependency, instead of having a global object with settings that is used everywhere.\n\nThis could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.\n\nComing from the previous example, your config.py file could look like:\n\nNotice that now we don't create a default instance settings = Settings().\n\nNow we create a dependency that returns a new config.Settings().\n\nWe'll discuss the @lru_cache in a bit.\n\nFor now you can assume get_settings() is a normal function.\n\nAnd then we can require it from the path operation function as a dependency and use it anywhere we need it.\n\nThen it would be very easy to provide a different settings object during testing by creating a dependency override for get_settings:\n\nIn the dependency override we set a new value for the admin_email when creating the new Settings object, and then we return that new object.\n\nThen we can test that it is used.\n\nIf you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.\n\nThis practice is common enough that it has a name, these environment variables are commonly placed in a file .env, and the file is called a \"dotenv\".\n\nA file starting with a dot (.) is a hidden file in Unix-like systems, like Linux and macOS.\n\nBut a dotenv file doesn't really have to have that exact filename.\n\nPydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support.\n\nFor this to work, you need to pip install python-dotenv.\n\nYou could have a .env file with:\n\nAnd then update your config.py with:\n\nThe model_config attribute is used just for Pydantic configuration. You can read more at Pydantic: Concepts: Configuration.\n\nThe Config class is used just for Pydantic configuration. You can read more at Pydantic Model Config.\n\nIn Pydantic version 1 the configuration was done in an internal class Config, in Pydantic version 2 it's done in an attribute model_config. This attribute takes a dict, and to get autocompletion and inline errors you can import and use SettingsConfigDict to define that dict.\n\nHere we define the config env_file inside of your Pydantic Settings class, and set the value to the filename with the dotenv file we want to use.\n\nReading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then reuse the same settings object, instead of reading it for each request.\n\nBut every time we do:\n\na new Settings object would be created, and at creation it would read the .env file again.\n\nIf the dependency function was just like:\n\nwe would create that object for each request, and we would be reading the .env file for each request. ⚠️\n\nBut as we are using the @lru_cache decorator on top, the Settings object will be created only once, the first time it's called. ✔️\n\nThen for any subsequent call of get_settings() in the dependencies for the next requests, instead of executing the internal code of get_settings() and creating a new Settings object, it will return the same object that was returned on the first call, again and again.\n\n@lru_cache modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.\n\nSo, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.\n\nFor example, if you have a function:\n\nyour program could execute like this:\n\nIn the case of our dependency get_settings(), the function doesn't even take any arguments, so it always returns the same value.\n\nThat way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.\n\n@lru_cache is part of functools which is part of Python's standard library, you can read more about it in the Python docs for @lru_cache.\n\nYou can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.",
  "headings": [
    {
      "level": "h1",
      "text": "Settings and Environment Variables¶",
      "id": "settings-and-environment-variables"
    },
    {
      "level": "h2",
      "text": "Types and validation¶",
      "id": "types-and-validation"
    },
    {
      "level": "h2",
      "text": "Pydantic Settings¶",
      "id": "pydantic-settings"
    },
    {
      "level": "h3",
      "text": "Install pydantic-settings¶",
      "id": "install-pydantic-settings"
    },
    {
      "level": "h3",
      "text": "Create the Settings object¶",
      "id": "create-the-settings-object"
    },
    {
      "level": "h3",
      "text": "Use the settings¶",
      "id": "use-the-settings"
    },
    {
      "level": "h3",
      "text": "Run the server¶",
      "id": "run-the-server"
    },
    {
      "level": "h2",
      "text": "Settings in another module¶",
      "id": "settings-in-another-module"
    },
    {
      "level": "h2",
      "text": "Settings in a dependency¶",
      "id": "settings-in-a-dependency"
    },
    {
      "level": "h3",
      "text": "The config file¶",
      "id": "the-config-file"
    },
    {
      "level": "h3",
      "text": "The main app file¶",
      "id": "the-main-app-file"
    },
    {
      "level": "h3",
      "text": "Settings and testing¶",
      "id": "settings-and-testing"
    },
    {
      "level": "h2",
      "text": "Reading a .env file¶",
      "id": "reading-a-env-file"
    },
    {
      "level": "h3",
      "text": "The .env file¶",
      "id": "the-env-file"
    },
    {
      "level": "h3",
      "text": "Read settings from .env¶",
      "id": "read-settings-from-env"
    },
    {
      "level": "h3",
      "text": "Creating the Settings only once with lru_cache¶",
      "id": "creating-the-settings-only-once-with-lru-cache"
    },
    {
      "level": "h4",
      "text": "lru_cache Technical Details¶",
      "id": "lru-cache-technical-details"
    },
    {
      "level": "h2",
      "text": "Recap¶",
      "id": "recap"
    }
  ],
  "code_samples": [
    {
      "code": "$ pip install pydantic-settings\n---> 100%",
      "language": "unknown"
    },
    {
      "code": "$ pip install \"fastapi[all]\"\n---> 100%",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n\nsettings = Settings()\napp = FastAPI()\n\n\n@app.get(\"/info\")\nasync def info():\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n\nsettings = Settings()\napp = FastAPI()\n\n\n@app.get(\"/info\")\nasync def info():\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n\nsettings = Settings()\napp = FastAPI()\n\n\n@app.get(\"/info\")\nasync def info():\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "$ ADMIN_EMAIL=\"deadpool@example.com\" APP_NAME=\"ChimichangApp\" fastapi run main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)",
      "language": "unknown"
    },
    {
      "code": "from pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n\nsettings = Settings()",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\n\nfrom .config import settings\n\napp = FastAPI()\n\n\n@app.get(\"/info\")\nasync def info():\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "from pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50",
      "language": "python"
    },
    {
      "code": "from functools import lru_cache\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\nfrom .config import Settings\n\napp = FastAPI()\n\n\n@lru_cache\ndef get_settings():\n    return Settings()\n\n\n@app.get(\"/info\")\nasync def info(settings: Annotated[Settings, Depends(get_settings)]):\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "from functools import lru_cache\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\nfrom .config import Settings\n\napp = FastAPI()\n\n\n@lru_cache\ndef get_settings():\n    return Settings()\n\n\n@app.get(\"/info\")\nasync def info(settings: Annotated[Settings, Depends(get_settings)]):\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "from fastapi.testclient import TestClient\n\nfrom .config import Settings\nfrom .main import app, get_settings\n\nclient = TestClient(app)\n\n\ndef get_settings_override():\n    return Settings(admin_email=\"testing_admin@example.com\")\n\n\napp.dependency_overrides[get_settings] = get_settings_override\n\n\ndef test_app():\n    response = client.get(\"/info\")\n    data = response.json()\n    assert data == {\n        \"app_name\": \"Awesome API\",\n        \"admin_email\": \"testing_admin@example.com\",\n        \"items_per_user\": 50,\n    }",
      "language": "python"
    },
    {
      "code": "ADMIN_EMAIL=\"deadpool@example.com\"\nAPP_NAME=\"ChimichangApp\"",
      "language": "unknown"
    },
    {
      "code": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n    model_config = SettingsConfigDict(env_file=\".env\")",
      "language": "python"
    },
    {
      "code": "from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = \"Awesome API\"\n    admin_email: str\n    items_per_user: int = 50\n\n    class Config:\n        env_file = \".env\"",
      "language": "python"
    },
    {
      "code": "def get_settings():\n    return Settings()",
      "language": "python"
    },
    {
      "code": "from functools import lru_cache\n\nfrom fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom . import config\n\napp = FastAPI()\n\n\n@lru_cache\ndef get_settings():\n    return config.Settings()\n\n\n@app.get(\"/info\")\nasync def info(settings: Annotated[config.Settings, Depends(get_settings)]):\n    return {\n        \"app_name\": settings.app_name,\n        \"admin_email\": settings.admin_email,\n        \"items_per_user\": settings.items_per_user,\n    }",
      "language": "python"
    },
    {
      "code": "@lru_cache\ndef say_hi(name: str, salutation: str = \"Ms.\"):\n    return f\"Hello {salutation} {name}\"",
      "language": "python"
    },
    {
      "code": "sequenceDiagram\n\nparticipant code as Code\nparticipant function as say_hi()\nparticipant execute as Execute function\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> code: return stored result\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Rick\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Rick\", salutation=\"Mr.\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Rick\")\n        function ->> code: return stored result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> code: return stored result\n    end",
      "language": "unknown"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/advanced/settings/",
    "https://fastapi.tiangolo.com/environment-variables/",
    "https://fastapi.tiangolo.com/virtual-environments/",
    "https://fastapi.tiangolo.com/tutorial/bigger-applications/"
  ]
}