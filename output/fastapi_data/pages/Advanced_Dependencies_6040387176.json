{
  "url": "https://fastapi.tiangolo.com/advanced/advanced-dependencies",
  "title": "Advanced DependenciesÂ¶",
  "content": "All the dependencies we have seen are a fixed function or class.\n\nBut there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.\n\nLet's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content.\n\nBut we want to be able to parameterize that fixed content.\n\nIn Python there's a way to make an instance of a class a \"callable\".\n\nNot the class itself (which is already a callable), but an instance of that class.\n\nTo do that, we declare a method __call__:\n\nPrefer to use the Annotated version if possible.\n\nIn this case, this __call__ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later.\n\nAnd now, we can use __init__ to declare the parameters of the instance that we can use to \"parameterize\" the dependency:\n\nPrefer to use the Annotated version if possible.\n\nIn this case, FastAPI won't ever touch or care about __init__, we will use it directly in our code.\n\nWe could create an instance of this class with:\n\nPrefer to use the Annotated version if possible.\n\nAnd that way we are able to \"parameterize\" our dependency, that now has \"bar\" inside of it, as the attribute checker.fixed_content.\n\nThen, we could use this checker in a Depends(checker), instead of Depends(FixedContentQueryChecker), because the dependency is the instance, checker, not the class itself.\n\nAnd when solving the dependency, FastAPI will call this checker like:\n\n...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed_content_included:\n\nPrefer to use the Annotated version if possible.\n\nAll this might seem contrived. And it might not be very clear how is it useful yet.\n\nThese examples are intentionally simple, but show how it all works.\n\nIn the chapters about security, there are utility functions that are implemented in this same way.\n\nIf you understood all this, you already know how those utility tools for security work underneath.\n\nYou most probably don't need these technical details.\n\nThese details are useful mainly if you had a FastAPI application older than 0.118.0 and you are facing issues with dependencies with yield.\n\nDependencies with yield have evolved over time to account for the different use cases and to fix some issues, here's a summary of what has changed.\n\nBefore FastAPI 0.118.0, if you used a dependency with yield, it would run the exit code after the path operation function returned but right before sending the response.\n\nThe intention was to avoid holding resources for longer than necessary, waiting for the response to travel through the network.\n\nThis change also meant that if you returned a StreamingResponse, the exit code of the dependency with yield would have been already run.\n\nFor example, if you had a database session in a dependency with yield, the StreamingResponse would not be able to use that session while streaming data because the session would have already been closed in the exit code after yield.\n\nThis behavior was reverted in 0.118.0, to make the exit code after yield be executed after the response is sent.\n\nAs you will see below, this is very similar to the behavior before version 0.106.0, but with several improvements and bug fixes for corner cases.\n\nThere are some use cases with specific conditions that could benefit from the old behavior of running the exit code of dependencies with yield before sending the response.\n\nFor example, imagine you have code that uses a database session in a dependency with yield only to verify a user, but the database session is never used again in the path operation function, only in the dependency, and the response takes a long time to be sent, like a StreamingResponse that sends data slowly, but for some reason doesn't use the database.\n\nIn this case, the database session would be held until the response is finished being sent, but if you don't use it, then it wouldn't be necessary to hold it.\n\nHere's how it could look like:\n\nThe exit code, the automatic closing of the Session in:\n\n...would be run after the the response finishes sending the slow data:\n\nBut as generate_stream() doesn't use the database session, it is not really necessary to keep the session open while sending the response.\n\nIf you have this specific use case using SQLModel (or SQLAlchemy), you could explicitly close the session after you don't need it anymore:\n\nThat way the session would release the database connection, so other requests could use it.\n\nIf you have a different use case that needs to exit early from a dependency with yield, please create a GitHub Discussion Question with your specific use case and why you would benefit from having early closing for dependencies with yield.\n\nIf there are compelling use cases for early closing in dependencies with yield, I would consider adding a new way to opt in to early closing.\n\nBefore FastAPI 0.110.0, if you used a dependency with yield, and then you captured an exception with except in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.\n\nThis was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.\n\nBefore FastAPI 0.106.0, raising exceptions after yield was not possible, the exit code in dependencies with yield was executed after the response was sent, so Exception Handlers would have already run.\n\nThis was designed this way mainly to allow using the same objects \"yielded\" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.\n\nThis was changed in FastAPI 0.106.0 with the intention to not hold resources while waiting for the response to travel through the network.\n\nAdditionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).\n\nSo, this way you will probably have cleaner code.\n\nIf you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with yield.\n\nFor example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.",
  "headings": [
    {
      "level": "h1",
      "text": "Advanced DependenciesÂ¶",
      "id": "advanced-dependencies"
    },
    {
      "level": "h2",
      "text": "Parameterized dependenciesÂ¶",
      "id": "parameterized-dependencies"
    },
    {
      "level": "h2",
      "text": "A \"callable\" instanceÂ¶",
      "id": "a-callable-instance"
    },
    {
      "level": "h2",
      "text": "Parameterize the instanceÂ¶",
      "id": "parameterize-the-instance"
    },
    {
      "level": "h2",
      "text": "Create an instanceÂ¶",
      "id": "create-an-instance"
    },
    {
      "level": "h2",
      "text": "Use the instance as a dependencyÂ¶",
      "id": "use-the-instance-as-a-dependency"
    },
    {
      "level": "h2",
      "text": "Dependencies with yield, HTTPException, except and Background TasksÂ¶",
      "id": "dependencies-with-yield-httpexception-except-and-background-tasks"
    },
    {
      "level": "h3",
      "text": "Dependencies with yield and StreamingResponse, Technical DetailsÂ¶",
      "id": "dependencies-with-yield-and-streamingresponse-technical-details"
    },
    {
      "level": "h4",
      "text": "Use Cases with Early Exit CodeÂ¶",
      "id": "use-cases-with-early-exit-code"
    },
    {
      "level": "h3",
      "text": "Dependencies with yield and except, Technical DetailsÂ¶",
      "id": "dependencies-with-yield-and-except-technical-details"
    },
    {
      "level": "h3",
      "text": "Background Tasks and Dependencies with yield, Technical DetailsÂ¶",
      "id": "background-tasks-and-dependencies-with-yield-technical-details"
    }
  ],
  "code_samples": [
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: bool = Depends(checker)):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: bool = Depends(checker)):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: bool = Depends(checker)):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "checker(q=\"somequery\")",
      "language": "unknown"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "from fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nclass FixedContentQueryChecker:\n    def __init__(self, fixed_content: str):\n        self.fixed_content = fixed_content\n\n    def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False\n\n\nchecker = FixedContentQueryChecker(\"bar\")\n\n\n@app.get(\"/query-checker/\")\nasync def read_query_check(fixed_content_included: bool = Depends(checker)):\n    return {\"fixed_content_in_query\": fixed_content_included}",
      "language": "python"
    },
    {
      "code": "import time\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi.responses import StreamingResponse\nfrom sqlmodel import Field, Session, SQLModel, create_engine\n\nengine = create_engine(\"postgresql+psycopg://postgres:postgres@localhost/db\")\n\n\nclass User(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str\n\n\napp = FastAPI()\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\ndef get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n\ndef generate_stream(query: str):\n    for ch in query:\n        yield ch\n        time.sleep(0.1)\n\n\n@app.get(\"/generate\", dependencies=[Depends(get_user)])\ndef generate(query: str):\n    return StreamingResponse(content=generate_stream(query))",
      "language": "python"
    },
    {
      "code": "# Code above omitted ðŸ‘†\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n# Code below omitted ðŸ‘‡",
      "language": "python"
    },
    {
      "code": "import time\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi.responses import StreamingResponse\nfrom sqlmodel import Field, Session, SQLModel, create_engine\n\nengine = create_engine(\"postgresql+psycopg://postgres:postgres@localhost/db\")\n\n\nclass User(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str\n\n\napp = FastAPI()\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\ndef get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n\ndef generate_stream(query: str):\n    for ch in query:\n        yield ch\n        time.sleep(0.1)\n\n\n@app.get(\"/generate\", dependencies=[Depends(get_user)])\ndef generate(query: str):\n    return StreamingResponse(content=generate_stream(query))",
      "language": "python"
    },
    {
      "code": "# Code above omitted ðŸ‘†\n\ndef generate_stream(query: str):\n    for ch in query:\n        yield ch\n        time.sleep(0.1)\n\n\n@app.get(\"/generate\", dependencies=[Depends(get_user)])\ndef generate(query: str):\n    return StreamingResponse(content=generate_stream(query))",
      "language": "python"
    },
    {
      "code": "import time\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi.responses import StreamingResponse\nfrom sqlmodel import Field, Session, SQLModel, create_engine\n\nengine = create_engine(\"postgresql+psycopg://postgres:postgres@localhost/db\")\n\n\nclass User(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str\n\n\napp = FastAPI()\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\ndef get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n\ndef generate_stream(query: str):\n    for ch in query:\n        yield ch\n        time.sleep(0.1)\n\n\n@app.get(\"/generate\", dependencies=[Depends(get_user)])\ndef generate(query: str):\n    return StreamingResponse(content=generate_stream(query))",
      "language": "python"
    },
    {
      "code": "# Code above omitted ðŸ‘†\n\ndef get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    session.close()\n\n# Code below omitted ðŸ‘‡",
      "language": "python"
    },
    {
      "code": "import time\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi.responses import StreamingResponse\nfrom sqlmodel import Field, Session, SQLModel, create_engine\n\nengine = create_engine(\"postgresql+psycopg://postgres:postgres@localhost/db\")\n\n\nclass User(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str\n\n\napp = FastAPI()\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\ndef get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    session.close()\n\n\ndef generate_stream(query: str):\n    for ch in query:\n        yield ch\n        time.sleep(0.1)\n\n\n@app.get(\"/generate\", dependencies=[Depends(get_user)])\ndef generate(query: str):\n    return StreamingResponse(content=generate_stream(query))",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/advanced/advanced-dependencies",
    "https://fastapi.tiangolo.com/handling-errors.md"
  ]
}