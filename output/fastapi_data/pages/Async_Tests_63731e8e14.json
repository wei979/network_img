{
  "url": "https://fastapi.tiangolo.com/advanced/async-tests/",
  "title": "Async Tests¶",
  "content": "You have already seen how to test your FastAPI applications using the provided TestClient. Up to now, you have only seen how to write synchronous tests, without using async functions.\n\nBeing able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.\n\nLet's look at how we can make that work.\n\nIf we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.\n\nEven if your FastAPI application uses normal def functions instead of async def, it is still an async application underneath.\n\nThe TestClient does some magic inside to call the asynchronous FastAPI application in your normal def test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the TestClient inside our test functions.\n\nThe TestClient is based on HTTPX, and luckily, we can use it directly to test the API.\n\nFor a simple example, let's consider a file structure similar to the one described in Bigger Applications and Testing:\n\nThe file main.py would have:\n\nThe file test_main.py would have the tests for main.py, it could look like this now:\n\nYou can run your tests as usual via:\n\nThe marker @pytest.mark.anyio tells pytest that this test function should be called asynchronously:\n\nNote that the test function is now async def instead of just def as before when using the TestClient.\n\nThen we can create an AsyncClient with the app, and send async requests to it, using await.\n\nThis is the equivalent to:\n\n...that we used to make our requests with the TestClient.\n\nNote that we're using async/await with the new AsyncClient - the request is asynchronous.\n\nIf your application relies on lifespan events, the AsyncClient won't trigger these events. To ensure they are triggered, use LifespanManager from florimondmanca/asgi-lifespan.\n\nAs the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n\nIf you encounter a RuntimeError: Task attached to a different loop when integrating asynchronous function calls in your tests (e.g. when using MongoDB's MotorClient), remember to instantiate objects that need an event loop only within async functions, e.g. an @app.on_event(\"startup\") callback.",
  "headings": [
    {
      "level": "h1",
      "text": "Async Tests¶",
      "id": "async-tests"
    },
    {
      "level": "h2",
      "text": "pytest.mark.anyio¶",
      "id": "pytest-mark-anyio"
    },
    {
      "level": "h2",
      "text": "HTTPX¶",
      "id": "httpx"
    },
    {
      "level": "h2",
      "text": "Example¶",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Run it¶",
      "id": "run-it"
    },
    {
      "level": "h2",
      "text": "In Detail¶",
      "id": "in-detail"
    },
    {
      "level": "h2",
      "text": "Other Asynchronous Function Calls¶",
      "id": "other-asynchronous-function-calls"
    }
  ],
  "code_samples": [
    {
      "code": ".\n├── app\n│   ├── __init__.py\n│   ├── main.py\n│   └── test_main.py",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Tomato\"}",
      "language": "python"
    },
    {
      "code": "import pytest\nfrom httpx import ASGITransport, AsyncClient\n\nfrom .main import app\n\n\n@pytest.mark.anyio\nasync def test_root():\n    async with AsyncClient(\n        transport=ASGITransport(app=app), base_url=\"http://test\"\n    ) as ac:\n        response = await ac.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Tomato\"}",
      "language": "python"
    },
    {
      "code": "$ pytest\n\n---> 100%",
      "language": "unknown"
    },
    {
      "code": "import pytest\nfrom httpx import ASGITransport, AsyncClient\n\nfrom .main import app\n\n\n@pytest.mark.anyio\nasync def test_root():\n    async with AsyncClient(\n        transport=ASGITransport(app=app), base_url=\"http://test\"\n    ) as ac:\n        response = await ac.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Tomato\"}",
      "language": "python"
    },
    {
      "code": "import pytest\nfrom httpx import ASGITransport, AsyncClient\n\nfrom .main import app\n\n\n@pytest.mark.anyio\nasync def test_root():\n    async with AsyncClient(\n        transport=ASGITransport(app=app), base_url=\"http://test\"\n    ) as ac:\n        response = await ac.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Tomato\"}",
      "language": "python"
    },
    {
      "code": "response = client.get('/')",
      "language": "unknown"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/advanced/async-tests/",
    "https://fastapi.tiangolo.com/tutorial/bigger-applications/",
    "https://fastapi.tiangolo.com/tutorial/testing/"
  ]
}