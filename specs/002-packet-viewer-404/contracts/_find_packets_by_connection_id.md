# Contract: `_find_packets_by_connection_id()`

**Method**: `NetworkAnalyzer._find_packets_by_connection_id(connection_id: str) -> set`
**File**: `network_analyzer.py`
**Type**: Private helper method

## Purpose

Extract packet indices for a connection by parsing its ID and scanning the packet list. This method serves as a fallback when timeline stages don't contain `packetRefs` (e.g., timeout connections).

## Signature

```python
def _find_packets_by_connection_id(self, connection_id: str) -> set:
    """Find packet indices for a connection by parsing its ID and scanning packets.

    This method handles all connection types by extracting the 5-tuple from the
    connection ID and matching it against packets in both directions.

    Args:
        connection_id: Connection identifier in one of these formats:
            - Standard: "{protocol}-{srcIp}-{srcPort}-{dstIp}-{dstPort}"
            - Timeout: "timeout-{srcIp}-{srcPort}-{dstIp}-{dstPort}-{packetIndex}"

    Returns:
        set: Set of packet indices (int) matching this connection. Returns empty
             set if connection ID is malformed or no packets match.

    Examples:
        >>> analyzer._find_packets_by_connection_id("tcp-10.1.1.14-5434-210.71.227.211-443")
        {4217, 4219, 4220}

        >>> analyzer._find_packets_by_connection_id("timeout-10.1.1.14-9492-172.64.153.46-443-4632")
        {4629, 4630, 4631, 4632, 4633}

        >>> analyzer._find_packets_by_connection_id("invalid-id")
        set()
    """
```

## Inputs

### `connection_id` (string, required)

Connection identifier string generated by timeline creation methods.

**Valid Formats**:

1. **Standard Connection**:
   - Pattern: `{protocol}-{srcIp}-{srcPort}-{dstIp}-{dstPort}`
   - Example: `tcp-10.1.1.14-5434-210.71.227.211-443`
   - Parts: `['tcp', '10.1.1.14', '5434', '210.71.227.211', '443']`

2. **Timeout Connection**:
   - Pattern: `timeout-{srcIp}-{srcPort}-{dstIp}-{dstPort}-{packetIndex}`
   - Example: `timeout-10.1.1.14-9492-172.64.153.46-443-4632`
   - Parts: `['timeout', '10.1.1.14', '9492', '172.64.153.46', '443', '4632']`

**Constraints**:
- Must contain hyphens as delimiters
- Ports must be valid integers (0-65535)
- IP addresses must be valid IPv4 format (not validated, but used for matching)

## Outputs

### Return Value: `set[int]`

Set of packet indices that match the connection's 5-tuple.

**Characteristics**:
- **Unordered**: Set type, order not guaranteed (caller sorts if needed)
- **Unique**: Each packet index appears at most once
- **Bidirectional**: Includes packets in BOTH directions (src→dst and dst→src)
- **Empty on error**: Returns `set()` for malformed IDs or no matches

**Examples**:

```python
# Success - TCP connection with 3 packets
{4217, 4219, 4220}

# Success - Timeout connection with 5 packets
{4629, 4630, 4631, 4632, 4633}

# Malformed ID - too few parts
set()

# Valid ID but no matching packets
set()
```

## Behavior

### Algorithm

```
1. Parse connection ID by splitting on '-'
2. Extract 5-tuple based on connection type:
   - Timeout: parts[0] == 'timeout', extract parts[1-4] (ignore parts[5])
   - Standard: parts[0] != 'timeout', extract parts[1-4]
3. Validate format:
   - Timeout: len(parts) >= 6
   - Standard: len(parts) >= 5
   - Return empty set if invalid
4. Scan all packets:
   - Check if packet has IP layer
   - Check if packet has TCP/UDP layer
   - Match 5-tuple bidirectionally
5. Return set of matching packet indices
```

### Matching Logic

**Bidirectional 5-Tuple Matching**:

```python
# Forward direction: src→dst
forward_match = (
    packet[IP].src == src_ip and
    packet[TCP/UDP].sport == src_port and
    packet[IP].dst == dst_ip and
    packet[TCP/UDP].dport == dst_port
)

# Reverse direction: dst→src
reverse_match = (
    packet[IP].src == dst_ip and
    packet[TCP/UDP].sport == dst_port and
    packet[IP].dst == src_ip and
    packet[TCP/UDP].dport == src_port
)

# Match if EITHER direction matches
if forward_match or reverse_match:
    matched_indices.add(packet_index)
```

### Performance

- **Time Complexity**: O(N) where N = total packets in capture
- **Space Complexity**: O(M) where M = matching packets (typically < 1000)
- **Expected Runtime**: < 100ms for 10K packets, < 500ms for 50K packets

## Edge Cases

### EC-1: Malformed Connection ID

**Input**: `"timeout-invalid"`

**Behavior**:
```python
parts = ['timeout', 'invalid']  # len(parts) = 2 < 6
return set()  # Too few parts
```

**Output**: `set()`

---

### EC-2: Invalid Port Number

**Input**: `"tcp-10.1.1.14-99999-210.71.227.211-443"`

**Behavior**:
```python
try:
    src_port = int(parts[2])  # 99999
    # Port validation not enforced (out of scope)
    # Matching will fail because no packet has port 99999
except ValueError:
    return set()  # Port is not an integer
```

**Output**: `set()` (no matching packets)

---

### EC-3: Non-IP Packets

**Input**: `"tcp-10.1.1.14-5434-210.71.227.211-443"`
**Packet List**: Contains ARP, ICMP, and non-IP packets

**Behavior**:
```python
for idx, packet in enumerate(self.packets):
    if not packet.haslayer(IP):
        continue  # Skip non-IP packets
    # ... matching logic
```

**Output**: Set containing only IP packet indices

---

### EC-4: Unidirectional Traffic

**Input**: `"timeout-10.1.1.14-9492-172.64.153.46-443-4632"`
**Scenario**: All packets from src→dst, none from dst→src

**Behavior**: Bidirectional matching still works, matches forward direction only

**Output**: `{4630, 4631, 4632}` (only forward packets)

---

### EC-5: No Matching Packets

**Input**: `"tcp-192.168.1.1-1234-192.168.1.2-5678"`
**Scenario**: No packets in capture match this 5-tuple

**Behavior**: Loop completes without matches

**Output**: `set()` (empty set, not None)

---

### EC-6: IPv6 Addresses (Future)

**Input**: `"tcp-2001:db8::1-5434-2001:db8::2-443"`

**Behavior**: Currently NOT supported (requires IPv6 layer check)

**Output**: `set()` (no matches because code only checks IPv4)

## Error Handling

### Invalid Input

**Error Type**: Malformed connection ID
**Handling**: Return empty set (no exceptions)
**Rationale**: Graceful degradation - empty packet list is acceptable

```python
# Example: Too few parts
if len(parts) < 6:  # For timeout
    return set()  # Don't raise exception
```

### Port Parsing Failure

**Error Type**: Port is not a valid integer
**Handling**: Catch ValueError, return empty set

```python
try:
    src_port = int(parts[2])
    dst_port = int(parts[4])
except ValueError:
    return set()  # Port is not numeric
```

### Packet Access Errors

**Error Type**: Missing layers in packet
**Handling**: Use `packet.haslayer()` checks, skip invalid packets

```python
if not packet.haslayer(IP):
    continue  # Skip, don't crash

if packet.haslayer(TCP):
    transport_layer = packet[TCP]
elif packet.haslayer(UDP):
    transport_layer = packet[UDP]
else:
    continue  # Skip, don't crash
```

## Dependencies

### Internal

- `self.packets`: List of packets loaded by `load_packets()`
- Must be called AFTER `load_packets()` completes

### External

- **scapy.all**: IP, TCP, UDP layers
- **Python stdlib**: No additional dependencies

## Constraints

### Preconditions

1. `self.packets` must be populated (non-empty list)
2. Connection ID must be a string (type validation not enforced)

### Postconditions

1. Return value is always a set (never None)
2. All returned indices are valid (0 <= idx < len(self.packets))
3. No side effects (pure function, doesn't modify state)

### Invariants

1. Returned set contains unique indices (set property)
2. If connection ID is malformed → return empty set (no crash)
3. Bidirectional matching always applied (not configurable)

## Testing

### Unit Tests

**Test Case 1: Parse Standard Connection ID**
```python
def test_parse_standard_connection_id():
    connection_id = "tcp-10.1.1.14-5434-210.71.227.211-443"
    result = analyzer._find_packets_by_connection_id(connection_id)
    assert isinstance(result, set)
    assert all(idx >= 0 for idx in result)
```

**Test Case 2: Parse Timeout Connection ID**
```python
def test_parse_timeout_connection_id():
    connection_id = "timeout-10.1.1.14-9492-172.64.153.46-443-4632"
    result = analyzer._find_packets_by_connection_id(connection_id)
    assert isinstance(result, set)
    # Should find packets matching 5-tuple (ignoring trailing index)
```

**Test Case 3: Bidirectional Matching**
```python
def test_bidirectional_matching():
    # Create packets in both directions
    # Forward: 10.1.1.14:5434 → 210.71.227.211:443
    # Reverse: 210.71.227.211:443 → 10.1.1.14:5434
    connection_id = "tcp-10.1.1.14-5434-210.71.227.211-443"
    result = analyzer._find_packets_by_connection_id(connection_id)
    assert len(result) >= 2  # At least forward and reverse packets
```

**Test Case 4: Malformed ID**
```python
def test_malformed_connection_id():
    result = analyzer._find_packets_by_connection_id("invalid")
    assert result == set()  # Empty set, no crash
```

**Test Case 5: No Matching Packets**
```python
def test_no_matching_packets():
    connection_id = "tcp-1.2.3.4-1234-5.6.7.8-5678"
    result = analyzer._find_packets_by_connection_id(connection_id)
    assert result == set()  # No matches
```

### Integration Tests

**Test Case 6: Real PCAP File**
```python
def test_with_real_pcap():
    analyzer = NetworkAnalyzer("test.pcap")
    analyzer.load_packets()

    # Get timeout connection from timeline
    timelines = analyzer.generate_protocol_timelines()
    timeout = [t for t in timelines['timelines'] if 'timeout' in t['id']][0]

    # Extract packets
    result = analyzer._find_packets_by_connection_id(timeout['id'])

    # Verify packet count matches timeline metrics
    assert len(result) <= timeout['metrics']['packetCount'] * 1.2  # Allow 20% tolerance
```

## Examples

### Example 1: Standard TCP Connection

```python
# Input
connection_id = "tcp-10.1.1.14-5434-210.71.227.211-443"

# Execution
parts = ['tcp', '10.1.1.14', '5434', '210.71.227.211', '443']
src_ip = '10.1.1.14'
src_port = 5434
dst_ip = '210.71.227.211'
dst_port = 443

# Scan packets
# Packet 4217: 10.1.1.14:5434 → 210.71.227.211:443 (SYN) ✓
# Packet 4219: 210.71.227.211:443 → 10.1.1.14:5434 (SYN-ACK) ✓
# Packet 4220: 10.1.1.14:5434 → 210.71.227.211:443 (ACK) ✓

# Output
{4217, 4219, 4220}
```

### Example 2: Timeout Connection

```python
# Input
connection_id = "timeout-10.1.1.14-9492-172.64.153.46-443-4632"

# Execution
parts = ['timeout', '10.1.1.14', '9492', '172.64.153.46', '443', '4632']
# Note: parts[5] = '4632' is ignored (not used for matching)
src_ip = '10.1.1.14'
src_port = 9492
dst_ip = '172.64.153.46'
dst_port = 443

# Scan packets (bidirectional)
# Packet 4629: 172.64.153.46:443 → 10.1.1.14:9492 ✓
# Packet 4630: 10.1.1.14:9492 → 172.64.153.46:443 ✓
# Packet 4632: 10.1.1.14:9492 → 172.64.153.46:443 ✓
# Packet 4633: 172.64.153.46:443 → 10.1.1.14:9492 ✓

# Output
{4629, 4630, 4632, 4633}
```

### Example 3: Malformed ID

```python
# Input
connection_id = "timeout-invalid"

# Execution
parts = ['timeout', 'invalid']
if len(parts) < 6:  # 2 < 6
    return set()

# Output
set()
```

## Future Enhancements

### Enhancement 1: Add IP Address Validation

Validate IP address format before scanning:

```python
import ipaddress

try:
    ipaddress.ip_address(src_ip)
    ipaddress.ip_address(dst_ip)
except ValueError:
    return set()  # Invalid IP format
```

### Enhancement 2: Port Range Validation

Enforce valid port range:

```python
if not (0 <= src_port <= 65535 and 0 <= dst_port <= 65535):
    return set()  # Invalid port
```

### Enhancement 3: Early Termination

Stop scanning when packet count reaches expected value:

```python
expected_count = timeline.get('metrics', {}).get('packetCount', float('inf'))
if len(matched_indices) >= expected_count:
    break  # Found all packets
```

### Enhancement 4: IPv6 Support

Add IPv6 layer checking:

```python
from scapy.all import IPv6

if packet.haslayer(IP):
    ip_layer = packet[IP]
elif packet.haslayer(IPv6):
    ip_layer = packet[IPv6]
else:
    continue
```
