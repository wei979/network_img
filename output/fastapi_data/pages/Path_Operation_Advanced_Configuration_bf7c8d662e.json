{
  "url": "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
  "title": "Path Operation Advanced Configuration¶",
  "content": "If you are not an \"expert\" in OpenAPI, you probably don't need this.\n\nYou can set the OpenAPI operationId to be used in your path operation with the parameter operation_id.\n\nYou would have to make sure that it is unique for each operation.\n\nIf you want to use your APIs' function names as operationIds, you can iterate over all of them and override each path operation's operation_id using their APIRoute.name.\n\nYou should do it after adding all your path operations.\n\nIf you manually call app.openapi(), you should update the operationIds before that.\n\nIf you do this, you have to make sure each one of your path operation functions has a unique name.\n\nEven if they are in different modules (Python files).\n\nTo exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include_in_schema and set it to False:\n\nYou can limit the lines used from the docstring of a path operation function for OpenAPI.\n\nAdding an \\f (an escaped \"form feed\" character) causes FastAPI to truncate the output used for OpenAPI at this point.\n\nIt won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.\n\nYou probably have seen how to declare the response_model and status_code for a path operation.\n\nThat defines the metadata about the main response of a path operation.\n\nYou can also declare additional responses with their models, status codes, etc.\n\nThere's a whole chapter here in the documentation about it, you can read it at Additional Responses in OpenAPI.\n\nWhen you declare a path operation in your application, FastAPI automatically generates the relevant metadata about that path operation to be included in the OpenAPI schema.\n\nIn the OpenAPI specification it is called the Operation Object.\n\nIt has all the information about the path operation and is used to generate the automatic documentation.\n\nIt includes the tags, parameters, requestBody, responses, etc.\n\nThis path operation-specific OpenAPI schema is normally generated automatically by FastAPI, but you can also extend it.\n\nThis is a low level extension point.\n\nIf you only need to declare additional responses, a more convenient way to do it is with Additional Responses in OpenAPI.\n\nYou can extend the OpenAPI schema for a path operation using the parameter openapi_extra.\n\nThis openapi_extra can be helpful, for example, to declare OpenAPI Extensions:\n\nIf you open the automatic API docs, your extension will show up at the bottom of the specific path operation.\n\nAnd if you see the resulting OpenAPI (at /openapi.json in your API), you will see your extension as part of the specific path operation too:\n\nThe dictionary in openapi_extra will be deeply merged with the automatically generated OpenAPI schema for the path operation.\n\nSo, you could add additional data to the automatically generated schema.\n\nFor example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.\n\nYou could do that with openapi_extra:\n\nIn this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as bytes, and the function magic_data_reader() would be in charge of parsing it in some way.\n\nNevertheless, we can declare the expected schema for the request body.\n\nUsing this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the path operation.\n\nAnd you could do this even if the data type in the request is not JSON.\n\nFor example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:\n\nIn Pydantic version 1 the method to get the JSON Schema for a model was called Item.schema(), in Pydantic version 2, the method is called Item.model_json_schema().\n\nNevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.\n\nThen we use the request directly, and extract the body as bytes. This means that FastAPI won't even try to parse the request payload as JSON.\n\nAnd then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:\n\nIn Pydantic version 1 the method to parse and validate an object was Item.parse_obj(), in Pydantic version 2, the method is called Item.model_validate().\n\nHere we reuse the same Pydantic model.\n\nBut the same way, we could have validated it in some other way.",
  "headings": [
    {
      "level": "h1",
      "text": "Path Operation Advanced Configuration¶",
      "id": "path-operation-advanced-configuration"
    },
    {
      "level": "h2",
      "text": "OpenAPI operationId¶",
      "id": "openapi-operationid"
    },
    {
      "level": "h3",
      "text": "Using the path operation function name as the operationId¶",
      "id": "using-the-path-operation-function-name-as-the-operationid"
    },
    {
      "level": "h2",
      "text": "Exclude from OpenAPI¶",
      "id": "exclude-from-openapi"
    },
    {
      "level": "h2",
      "text": "Advanced description from docstring¶",
      "id": "advanced-description-from-docstring"
    },
    {
      "level": "h2",
      "text": "Additional Responses¶",
      "id": "additional-responses"
    },
    {
      "level": "h2",
      "text": "OpenAPI Extra¶",
      "id": "openapi-extra"
    },
    {
      "level": "h3",
      "text": "OpenAPI Extensions¶",
      "id": "openapi-extensions"
    },
    {
      "level": "h3",
      "text": "Custom OpenAPI path operation schema¶",
      "id": "custom-openapi-path-operation-schema"
    },
    {
      "level": "h3",
      "text": "Custom OpenAPI content type¶",
      "id": "custom-openapi-content-type"
    }
  ],
  "code_samples": [
    {
      "code": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/items/\", operation_id=\"some_specific_id_you_define\")\nasync def read_items():\n    return [{\"item_id\": \"Foo\"}]",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\nfrom fastapi.routing import APIRoute\n\napp = FastAPI()\n\n\n@app.get(\"/items/\")\nasync def read_items():\n    return [{\"item_id\": \"Foo\"}]\n\n\ndef use_route_names_as_operation_ids(app: FastAPI) -> None:\n    \"\"\"\n    Simplify operation IDs so that generated API clients have simpler function\n    names.\n\n    Should be called only after all routes have been added.\n    \"\"\"\n    for route in app.routes:\n        if isinstance(route, APIRoute):\n            route.operation_id = route.name  # in this case, 'read_items'\n\n\nuse_route_names_as_operation_ids(app)",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/items/\", include_in_schema=False)\nasync def read_items():\n    return [{\"item_id\": \"Foo\"}]",
      "language": "python"
    },
    {
      "code": "from typing import Set, Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: Set[str] = set()\n\n\n@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\nasync def create_item(item: Item):\n    \"\"\"\n    Create an item with all the information:\n\n    - **name**: each item must have a name\n    - **description**: a long description\n    - **price**: required\n    - **tax**: if the item doesn't have tax, you can omit this\n    - **tags**: a set of unique tag strings for this item\n    \\f\n    :param item: User input.\n    \"\"\"\n    return item",
      "language": "python"
    },
    {
      "code": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/items/\", openapi_extra={\"x-aperture-labs-portal\": \"blue\"})\nasync def read_items():\n    return [{\"item_id\": \"portal-gun\"}]",
      "language": "python"
    },
    {
      "code": "{\n    \"openapi\": \"3.1.0\",\n    \"info\": {\n        \"title\": \"FastAPI\",\n        \"version\": \"0.1.0\"\n    },\n    \"paths\": {\n        \"/items/\": {\n            \"get\": {\n                \"summary\": \"Read Items\",\n                \"operationId\": \"read_items_items__get\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {}\n                            }\n                        }\n                    }\n                },\n                \"x-aperture-labs-portal\": \"blue\"\n            }\n        }\n    }\n}",
      "language": "unknown"
    },
    {
      "code": "from fastapi import FastAPI, Request\n\napp = FastAPI()\n\n\ndef magic_data_reader(raw_body: bytes):\n    return {\n        \"size\": len(raw_body),\n        \"content\": {\n            \"name\": \"Maaaagic\",\n            \"price\": 42,\n            \"description\": \"Just kiddin', no magic here. ✨\",\n        },\n    }\n\n\n@app.post(\n    \"/items/\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"required\": [\"name\", \"price\"],\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"name\": {\"type\": \"string\"},\n                            \"price\": {\"type\": \"number\"},\n                            \"description\": {\"type\": \"string\"},\n                        },\n                    }\n                }\n            },\n            \"required\": True,\n        },\n    },\n)\nasync def create_item(request: Request):\n    raw_body = await request.body()\n    data = magic_data_reader(raw_body)\n    return data",
      "language": "python"
    },
    {
      "code": "from typing import List\n\nimport yaml\nfrom fastapi import FastAPI, HTTPException, Request\nfrom pydantic import BaseModel, ValidationError\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    tags: List[str]\n\n\n@app.post(\n    \"/items/\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\"application/x-yaml\": {\"schema\": Item.model_json_schema()}},\n            \"required\": True,\n        },\n    },\n)\nasync def create_item(request: Request):\n    raw_body = await request.body()\n    try:\n        data = yaml.safe_load(raw_body)\n    except yaml.YAMLError:\n        raise HTTPException(status_code=422, detail=\"Invalid YAML\")\n    try:\n        item = Item.model_validate(data)\n    except ValidationError as e:\n        raise HTTPException(status_code=422, detail=e.errors(include_url=False))\n    return item",
      "language": "python"
    },
    {
      "code": "from typing import List\n\nimport yaml\nfrom fastapi import FastAPI, HTTPException, Request\nfrom pydantic import BaseModel, ValidationError\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    tags: List[str]\n\n\n@app.post(\n    \"/items/\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\"application/x-yaml\": {\"schema\": Item.schema()}},\n            \"required\": True,\n        },\n    },\n)\nasync def create_item(request: Request):\n    raw_body = await request.body()\n    try:\n        data = yaml.safe_load(raw_body)\n    except yaml.YAMLError:\n        raise HTTPException(status_code=422, detail=\"Invalid YAML\")\n    try:\n        item = Item.parse_obj(data)\n    except ValidationError as e:\n        raise HTTPException(status_code=422, detail=e.errors())\n    return item",
      "language": "python"
    },
    {
      "code": "from typing import List\n\nimport yaml\nfrom fastapi import FastAPI, HTTPException, Request\nfrom pydantic import BaseModel, ValidationError\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    tags: List[str]\n\n\n@app.post(\n    \"/items/\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\"application/x-yaml\": {\"schema\": Item.model_json_schema()}},\n            \"required\": True,\n        },\n    },\n)\nasync def create_item(request: Request):\n    raw_body = await request.body()\n    try:\n        data = yaml.safe_load(raw_body)\n    except yaml.YAMLError:\n        raise HTTPException(status_code=422, detail=\"Invalid YAML\")\n    try:\n        item = Item.model_validate(data)\n    except ValidationError as e:\n        raise HTTPException(status_code=422, detail=e.errors(include_url=False))\n    return item",
      "language": "python"
    },
    {
      "code": "from typing import List\n\nimport yaml\nfrom fastapi import FastAPI, HTTPException, Request\nfrom pydantic import BaseModel, ValidationError\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    tags: List[str]\n\n\n@app.post(\n    \"/items/\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\"application/x-yaml\": {\"schema\": Item.schema()}},\n            \"required\": True,\n        },\n    },\n)\nasync def create_item(request: Request):\n    raw_body = await request.body()\n    try:\n        data = yaml.safe_load(raw_body)\n    except yaml.YAMLError:\n        raise HTTPException(status_code=422, detail=\"Invalid YAML\")\n    try:\n        item = Item.parse_obj(data)\n    except ValidationError as e:\n        raise HTTPException(status_code=422, detail=e.errors())\n    return item",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
    "https://fastapi.tiangolo.com/advanced/additional-responses/"
  ]
}