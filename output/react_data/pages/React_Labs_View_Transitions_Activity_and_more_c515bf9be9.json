{
  "url": "https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more",
  "title": "React Labs: View Transitions, Activity, and more",
  "content": "April 23, 2025 by Ricky Hanlon\n\nIn React Labs posts, we write about projects in active research and development. In this post, we’re sharing two new experimental features that are ready to try today, and updates on other areas we’re working on now.\n\nToday, we’re excited to release documentation for two new experimental features that are ready for testing:\n\nWe’re also sharing updates on new features currently in development:\n\n<Activity /> has shipped in react@19.2.\n\n<ViewTransition /> and addTransitionType are now available in react@canary.\n\nView Transitions and Activity are now ready for testing in react@experimental. These features have been tested in production and are stable, but the final API may still change as we incorporate feedback.\n\nYou can try them by upgrading React packages to the most recent experimental version:\n\nRead on to learn how to use these features in your app, or check out the newly published docs:\n\nReact View Transitions are a new experimental feature that makes it easier to add animations to UI transitions in your app. Under-the-hood, these animations use the new startViewTransition API available in most modern browsers.\n\nTo opt-in to animating an element, wrap it in the new <ViewTransition> component:\n\nThis new component lets you declaratively define “what” to animate when an animation is activated.\n\nYou can define “when” to animate by using one of these three triggers for a View Transition:\n\nBy default, these animations use the default CSS animations for View Transitions applied (typically a smooth cross-fade). You can use view transition pseudo-selectors to define “how” the animation runs. For example, you can use * to change the default animation for all transitions:\n\nWhen the DOM updates due to an animation trigger—like startTransition, useDeferredValue, or a Suspense fallback switching to content—React will use declarative heuristics to automatically determine which <ViewTransition> components to activate for the animation. The browser will then run the animation that’s defined in CSS.\n\nIf you’re familiar with the browser’s View Transition API and want to know how React supports it, check out How does <ViewTransition> Work in the docs.\n\nIn this post, let’s take a look at a few examples of how to use View Transitions.\n\nWe’ll start with this app, which doesn’t animate any of the following interactions:\n\nView Transitions are meant to be used for UI transitions such as navigation, expanding, opening, or re-ordering. They are not meant to replace all the animations in your app.\n\nIn our example app above, notice that there are already animations when you click the “like” button and in the Suspense fallback glimmer. These are good use cases for CSS animations because they are animating a specific element.\n\nOur app includes a Suspense-enabled router, with page transitions already marked as Transitions, which means navigations are performed with startTransition:\n\nstartTransition is a View Transition trigger, so we can add <ViewTransition> to animate between pages:\n\nWhen the url changes, the <ViewTransition> and new route are rendered. Since the <ViewTransition> was updated inside of startTransition, the <ViewTransition> is activated for an animation.\n\nBy default, View Transitions include the browser default cross-fade animation. Adding this to our example, we now have a cross-fade whenever we navigate between pages:\n\nSince our router already updates the route using startTransition, this one line change to add <ViewTransition> activates with the default cross-fade animation.\n\nIf you’re curious how this works, see the docs for How does <ViewTransition> work?\n\nIn this example, we’re wrapping the root of the app in <ViewTransition> for simplicity, but this means that all transitions in the app will be animated, which can lead to unexpected animations.\n\nTo fix, we’re wrapping route children with \"none\" so each page can control its own animation:\n\nIn practice, navigations should be done via “enter” and “exit” props, or by using Transition Types.\n\nBy default, <ViewTransition> includes the default cross-fade from the browser.\n\nTo customize animations, you can provide props to the <ViewTransition> component to specify which animations to use, based on how the <ViewTransition> activates.\n\nFor example, we can slow down the default cross fade animation:\n\nAnd define slow-fade in CSS using view transition classes:\n\nNow, the cross fade is slower:\n\nSee Styling View Transitions for a full guide on styling <ViewTransition>.\n\nWhen two pages include the same element, often you want to animate it from one page to the next.\n\nTo do this you can add a unique name to the <ViewTransition>:\n\nNow the video thumbnail animates between the two pages:\n\nBy default, React automatically generates a unique name for each element activated for a transition (see How does <ViewTransition> work). When React sees a transition where a <ViewTransition> with a name is removed and a new <ViewTransition> with the same name is added, it will activate a shared element transition.\n\nFor more info, see the docs for Animating a Shared Element.\n\nSometimes, you may want elements to animate differently based on how it was triggered. For this use case, we’ve added a new API called addTransitionType to specify the cause of a transition:\n\nWith transition types, you can provide custom animations via props to <ViewTransition>. Let’s add a shared element transition to the header for “6 Videos” and “Back”:\n\nHere we pass a share prop to define how to animate based on the transition type. When the share transition activates from nav-forward, the view transition class slide-forward is applied. When it’s from nav-back, the slide-back animation is activated. Let’s define these animations in CSS:\n\nNow we can animate the header along with thumbnail based on navigation type:\n\nSuspense will also activate View Transitions.\n\nTo animate the fallback to content, we can wrap Suspense with <ViewTranstion>:\n\nBy adding this, the fallback will cross-fade into the content. Click a video and see the video info animate in:\n\nWe can also provide custom animations using an exit on the fallback, and enter on the content:\n\nHere’s how we’ll define slide-down and slide-up with CSS:\n\nNow, the Suspense content replaces the fallback with a sliding animation:\n\nYou can also use <ViewTransition> to animate lists of items as they re-order, like in a searchable list of items:\n\nTo activate the ViewTransition, we can use useDeferredValue:\n\nNow the items animate as you type in the search bar:\n\nBy adding a few <ViewTransition> components and a few lines of CSS, we were able to add all the animations above into the final result.\n\nWe’re excited about View Transitions and think they will level up the apps you’re able to build. They’re ready to start trying today in the experimental channel of React releases.\n\nLet’s remove the slow fade, and take a look at the final result:\n\nIf you’re curious to know more about how they work, check out How Does <ViewTransition> Work in the docs.\n\nFor more background on how we built View Transitions, see: #31975, #32105, #32041, #32734, #32797 #31999, #32031, #32050, #32820, #32029, #32028, and #32038 by @sebmarkbage (thanks Seb!).\n\n<Activity /> is now available in React’s Canary channel.\n\nLearn more about React’s release channels here.\n\nIn past updates, we shared that we were researching an API to allow components to be visually hidden and deprioritized, preserving UI state with reduced performance costs relative to unmounting or hiding with CSS.\n\nWe’re now ready to share the API and how it works, so you can start testing it in experimental React versions.\n\n<Activity> is a new component to hide and show parts of the UI:\n\nWhen an Activity is visible it’s rendered as normal. When an Activity is hidden it is unmounted, but will save its state and continue to render at a lower priority than anything visible on screen.\n\nYou can use Activity to save state for parts of the UI the user isn’t using, or pre-render parts that a user is likely to use next.\n\nLet’s look at some examples improving the View Transition examples above.\n\nEffects don’t mount when an Activity is hidden.\n\nWhen an <Activity> is hidden, Effects are unmounted. Conceptually, the component is unmounted, but React saves the state for later.\n\nIn practice, this works as expected if you have followed the You Might Not Need an Effect guide. To eagerly find problematic Effects, we recommend adding <StrictMode> which will eagerly perform Activity unmounts and mounts to catch any unexpected side effects.\n\nWhen a user navigates away from a page, it’s common to stop rendering the old page:\n\nHowever, this means if the user goes back to the old page, all of the previous state is lost. For example, if the <Home /> page has an <input> field, when the user leaves the page the <input> is unmounted, and all of the text they had typed is lost.\n\nActivity allows you to keep the state around as the user changes pages, so when they come back they can resume where they left off. This is done by wrapping part of the tree in <Activity> and toggling the mode:\n\nWith this change, we can improve on our View Transitions example above. Before, when you searched for a video, selected one, and returned, your search filter was lost. With Activity, your search filter is restored and you can pick up where you left off.\n\nTry searching for a video, selecting it, and clicking “back”:\n\nSometimes, you may want to prepare the next part of the UI a user is likely to use ahead of time, so it’s ready by the time they are ready to use it. This is especially useful if the next route needs to suspend on data it needs to render, because you can help ensure the data is already fetched before the user navigates.\n\nFor example, our app currently needs to suspend to load the data for each video when you select one. We can improve this by rendering all of the pages in a hidden <Activity> until the user navigates:\n\nWith this update, if the content on the next page has time to pre-render, it will animate in without the Suspense fallback. Click a video, and notice that the video title and description on the Details page render immediately, without a fallback:\n\nWhen using Activity on a page that uses server-side rendering (SSR), there are additional optimizations.\n\nIf part of the page is rendered with mode=\"hidden\", then it will not be included in the SSR response. Instead, React will schedule a client render for the content inside Activity while the rest of the page hydrates, prioritizing the visible content on screen.\n\nFor parts of the UI rendered with mode=\"visible\", React will de-prioritize hydration of content within Activity, similar to how Suspense content is hydrated at a lower priority. If the user interacts with the page, we’ll prioritize hydration within the boundary if needed.\n\nThese are advanced use cases, but they show the additional benefits considered with Activity.\n\nIn the future, we may add more modes to Activity.\n\nFor example, a common use case is rendering a modal, where the previous “inactive” page is visible behind the “active” modal view. The “hidden” mode does not work for this use case because it’s not visible and not included in SSR.\n\nInstead, we’re considering a new mode that would keep the content visible—and included in SSR—but keep it unmounted and de-prioritize updates. This mode may also need to “pause” DOM updates, since it can be distracting to see backgrounded content updating while a modal is open.\n\nAnother mode we’re considering for Activity is the ability to automatically destroy state for hidden Activities if there is too much memory being used. Since the component is already unmounted, it may be preferable to destroy state for the least recently used hidden parts of the app rather than consume too many resources.\n\nThese are areas we’re still exploring, and we’ll share more as we make progress. For more information on what Activity includes today, check out the docs.\n\nWe’re also developing features to help solve the common problems below.\n\nAs we iterate on possible solutions, you may see some potential APIs we’re testing being shared based on the PRs we are landing. Please keep in mind that as we try different ideas, we often change or remove different solutions after trying them out.\n\nWhen the solutions we’re working on are shared too early, it can create churn and confusion in the community. To balance being transparent and limiting confusion, we’re sharing the problems we’re currently developing solutions for, without sharing a particular solution we have in mind.\n\nAs these features progress, we’ll announce them on the blog with docs included so you can try them out.\n\nWe’re working on a new set of custom tracks to performance profilers using browser APIs that allow adding custom tracks to provide more information about the performance of your React app.\n\nThis feature is still in progress, so we’re not ready to publish docs to fully release it as an experimental feature yet. You can get a sneak preview when using an experimental version of React, which will automatically add the performance tracks to profiles:\n\nThere are a few known issues we plan to address such as performance, and the scheduler track not always “connecting” work across Suspended trees, so it’s not quite ready to try. We’re also still collecting feedback from early adopters to improve the design and usability of the tracks.\n\nOnce we solve those issues, we’ll publish experimental docs and share that it’s ready to try.\n\nWhen we released hooks, we had three motivations:\n\nSince their release, hooks have been successful at sharing code between components. Hooks are now the favored way to share logic between components, and there are less use cases for render props and higher order components. Hooks have also been successful at supporting features like Fast Refresh that were not possible with class components.\n\nUnfortunately, some hooks are still hard to think in terms of function instead of lifecycles. Effects specifically are still hard to understand and are the most common pain point we hear from developers. Last year, we spent a significant amount of time researching how Effects were used, and how those use cases could be simplified and easier to understand.\n\nWe found that often, the confusion is from using an Effect when you don’t need to. The You Might Not Need an Effect guide covers many cases for when Effects are not the right solution. However, even when an Effect is the right fit for a problem, Effects can still be harder to understand than class component lifecycles.\n\nWe believe one of the reasons for confusion is that developers to think of Effects from the component’s perspective (like a lifecycle), instead of the Effects point of view (what the Effect does).\n\nLet’s look at an example from the docs:\n\nMany users would read this code as “on mount, connect to the roomId. whenever roomId changes, disconnect to the old room and re-create the connection”. However, this is thinking from the component’s lifecycle perspective, which means you will need to think of every component lifecycle state to write the Effect correctly. This can be difficult, so it’s understandable that Effects seem harder than class lifecycles when using the component perspective.\n\nInstead, it’s better to think from the Effect’s perspective. The Effect doesn’t know about the component lifecycles. It only describes how to start synchronization and how to stop it. When users think of Effects in this way, their Effects tend to be easier to write, and more resilient to being started and stopped as many times as is needed.\n\nWe spent some time researching why Effects are thought of from the component perspective, and we think one of the reasons is the dependency array. Since you have to write it, it’s right there and in your face reminding you of what you’re “reacting” to and baiting you into the mental model of ‘do this when these values change’.\n\nWhen we released hooks, we knew we could make them easier to use with ahead-of-time compilation. With the React Compiler, you’re now able to avoid writing useCallback and useMemo yourself in most cases. For Effects, the compiler can insert the dependencies for you:\n\nWith this code, the React Compiler can infer the dependencies for you and insert them automatically so you don’t need to see or write them. With features like the IDE extension and useEffectEvent, we can provide a CodeLens to show you what the Compiler inserted for times you need to debug, or to optimize by removing a dependency. This helps reinforce the correct mental model for writing Effects, which can run at any time to synchronize your component or hook’s state with something else.\n\nOur hope is that automatically inserting dependencies is not only easier to write, but that it also makes them easier to understand by forcing you to think in terms of what the Effect does, and not in component lifecycles.\n\nLater in 2025 we shared the first stable release of React Compiler, and we’re continuing to invest in shipping more improvements.\n\nWe’ve also begun exploring ways to use the React Compiler to provide information that can improve understanding and debugging your code. One idea we’ve started exploring is a new experimental LSP-based React IDE extension powered by React Compiler, similar to the extension used in Lauren Tan’s React Conf talk.\n\nOur idea is that we can use the compiler’s static analysis to provide more information, suggestions, and optimization opportunities directly in your IDE. For example, we can provide diagnostics for code breaking the Rules of React, hovers to show if components and hooks were optimized by the compiler, or a CodeLens to see automatically inserted Effect dependencies.\n\nThe IDE extension is still an early exploration, but we’ll share our progress in future updates.\n\nMany DOM APIs like those for event management, positioning, and focus are difficult to compose when writing with React. This often leads developers to reach for Effects, managing multiple Refs, by using APIs like findDOMNode (removed in React 19).\n\nWe are exploring adding refs to Fragments that would point to a group of DOM elements, rather than just a single element. Our hope is that this will simplify managing multiple children and make it easier to write composable React code when calling DOM APIs.\n\nFragment refs are still being researched. We’ll share more when we’re closer to having the final API finished.\n\nWe’re also researching ways to enhance View Transitions to support gesture animations such as swiping to open a menu, or scroll through a photo carousel.\n\nGestures present new challenges for a few reasons:\n\nWe believe we’ve found an approach that works well and may introduce a new API for triggering gesture transitions. For now, we’re focused on shipping <ViewTransition>, and will revisit gestures afterward.\n\nWhen we released React 18 with concurrent rendering, we also released useSyncExternalStore so external store libraries that did not use React state or context could support concurrent rendering by forcing a synchronous render when the store is updated.\n\nUsing useSyncExternalStore comes at a cost though, since it forces a bail out from concurrent features like transitions, and forces existing content to show Suspense fallbacks.\n\nNow that React 19 has shipped, we’re revisiting this problem space to create a primitive to fully support concurrent external stores with the use API:\n\nOur goal is to allow external state to be read during render without tearing, and to work seamlessly with all of the concurrent features React offers.\n\nThis research is still early. We’ll share more, and what the new APIs will look like, when we’re further along.\n\nThanks to Aurora Scharff, Dan Abramov, Eli White, Lauren Tan, Luna Wei, Matt Carroll, Jack Pope, Jason Bonta, Jordan Brown, Jordan Eldredge, Mofei Zhang, Sebastien Lorber, Sebastian Markbåge, and Tim Yung for reviewing this post.",
  "headings": [
    {
      "level": "h1",
      "text": "React Labs: View Transitions, Activity, and more",
      "id": ""
    },
    {
      "level": "h1",
      "text": "New Experimental Features",
      "id": "new-experimental-features"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "View Transitions",
      "id": "view-transitions"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h4",
      "text": "View Transitions do not replace CSS and JS driven animations",
      "id": "view-transitions-do-not-replace-css-and-js-driven-animations"
    },
    {
      "level": "h3",
      "text": "Animating navigations",
      "id": "animating-navigations"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Opting out of <ViewTransition> animations",
      "id": "opting-out-of-viewtransition-animations"
    },
    {
      "level": "h3",
      "text": "Customizing animations",
      "id": "customizing-animations"
    },
    {
      "level": "h3",
      "text": "Shared Element Transitions",
      "id": "shared-element-transitions"
    },
    {
      "level": "h3",
      "text": "Animating based on cause",
      "id": "animating-based-on-cause"
    },
    {
      "level": "h3",
      "text": "Animating Suspense Boundaries",
      "id": "animating-suspense-boundaries"
    },
    {
      "level": "h3",
      "text": "Animating Lists",
      "id": "animating-lists"
    },
    {
      "level": "h3",
      "text": "Final result",
      "id": "final-result"
    },
    {
      "level": "h2",
      "text": "Activity",
      "id": "activity"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Restoring state with Activity",
      "id": "restoring-state-with-activity"
    },
    {
      "level": "h3",
      "text": "Pre-rendering with Activity",
      "id": "prerender-with-activity"
    },
    {
      "level": "h3",
      "text": "Server-Side Rendering with Activity",
      "id": "server-side-rendering-with-activity"
    },
    {
      "level": "h3",
      "text": "Future modes for Activity",
      "id": "future-modes-for-activity"
    },
    {
      "level": "h1",
      "text": "Features in development",
      "id": "features-in-development"
    },
    {
      "level": "h2",
      "text": "React Performance Tracks",
      "id": "react-performance-tracks"
    },
    {
      "level": "h2",
      "text": "Automatic Effect Dependencies",
      "id": "automatic-effect-dependencies"
    },
    {
      "level": "h3",
      "text": "Effects can be hard",
      "id": "effects-can-be-hard"
    },
    {
      "level": "h3",
      "text": "Effects without dependencies",
      "id": "effects-without-dependencies"
    },
    {
      "level": "h2",
      "text": "Compiler IDE Extension",
      "id": "compiler-ide-extension"
    },
    {
      "level": "h2",
      "text": "Fragment Refs",
      "id": "fragment-refs"
    },
    {
      "level": "h2",
      "text": "Gesture Animations",
      "id": "gesture-animations"
    },
    {
      "level": "h2",
      "text": "Concurrent Stores",
      "id": "concurrent-stores"
    }
  ],
  "code_samples": [
    {
      "code": "// \"what\" to animate.<ViewTransition>  <div>animate me</div></ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "// \"when\" to animate.// TransitionsstartTransition(() => setState(...));// Deferred Valuesconst deferred = useDeferredValue(value);// Suspense<Suspense fallback={<Fallback />}>  <div>Loading...</div></Suspense>",
      "language": "javascript"
    },
    {
      "code": "// \"how\" to animate.::view-transition-old(*) {  animation: 300ms ease-out fade-out;}::view-transition-new(*) {  animation: 300ms ease-in fade-in;}",
      "language": "unknown"
    },
    {
      "code": "function navigate(url) {  startTransition(() => {    go(url);  });}",
      "language": "javascript"
    },
    {
      "code": "// \"what\" to animate<ViewTransition key={url}>  {url === '/' ? <Home /> : <TalkDetails />}</ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "// Layout.js<ViewTransition default=\"none\">  {children}</ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "<ViewTransition default=\"slow-fade\">  <Home /></ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "::view-transition-old(.slow-fade) {    animation-duration: 500ms;}::view-transition-new(.slow-fade) {    animation-duration: 500ms;}",
      "language": "unknown"
    },
    {
      "code": "<ViewTransition name={`video-${video.id}`}>  <Thumbnail video={video} /></ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "function navigate(url) {  startTransition(() => {    // Transition type for the cause \"nav forward\"    addTransitionType('nav-forward');    go(url);  });}function navigateBack(url) {  startTransition(() => {    // Transition type for the cause \"nav backward\"    addTransitionType('nav-back');    go(url);  });}",
      "language": "javascript"
    },
    {
      "code": "<ViewTransition  name=\"nav\"  share={{    'nav-forward': 'slide-forward',    'nav-back': 'slide-back',  }}>  {heading}</ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "::view-transition-old(.slide-forward) {    /* when sliding forward, the \"old\" page should slide out to left. */    animation: ...}::view-transition-new(.slide-forward) {    /* when sliding forward, the \"new\" page should slide in from right. */    animation: ...}::view-transition-old(.slide-back) {    /* when sliding back, the \"old\" page should slide out to right. */    animation: ...}::view-transition-new(.slide-back) {    /* when sliding back, the \"new\" page should slide in from left. */    animation: ...}",
      "language": "unknown"
    },
    {
      "code": "<ViewTransition>  <Suspense fallback={<VideoInfoFallback />}>    <VideoInfo />  </Suspense></ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "<Suspense  fallback={    <ViewTransition exit=\"slide-down\">      <VideoInfoFallback />    </ViewTransition>  }>  <ViewTransition enter=\"slide-up\">    <VideoInfo id={id} />  </ViewTransition></Suspense>",
      "language": "unknown"
    },
    {
      "code": "::view-transition-old(.slide-down) {  /* Slide the fallback down */  animation: ...;}::view-transition-new(.slide-up) {  /* Slide the content up */  animation: ...;}",
      "language": "unknown"
    },
    {
      "code": "<div className=\"videos\">  {filteredVideos.map((video) => (    <ViewTransition key={video.id}>      <Video video={video} />    </ViewTransition>  ))}</div>",
      "language": "javascript"
    },
    {
      "code": "const [searchText, setSearchText] = useState('');const deferredSearchText = useDeferredValue(searchText);const filteredVideos = filterVideos(videos, deferredSearchText);",
      "language": "javascript"
    },
    {
      "code": "<Activity mode={isVisible ? 'visible' : 'hidden'}>  <Page /></Activity>",
      "language": "unknown"
    },
    {
      "code": "function App() {  const { url } = useRouter();  return (    <>      {url === '/' && <Home />}      {url !== '/' && <Details />}    </>  );}",
      "language": "javascript"
    },
    {
      "code": "function App() {  const { url } = useRouter();  return (    <>      <Activity mode={url === '/' ? 'visible' : 'hidden'}>        <Home />      </Activity>      {url !== '/' && <Details />}    </>  );}",
      "language": "javascript"
    },
    {
      "code": "<ViewTransition>  <Activity mode={url === '/' ? 'visible' : 'hidden'}>    <Home />  </Activity>  <Activity mode={url === '/details/1' ? 'visible' : 'hidden'}>    <Details id={id} />  </Activity>  <Activity mode={url === '/details/1' ? 'visible' : 'hidden'}>    <Details id={id} />  </Activity><ViewTransition>",
      "language": "unknown"
    },
    {
      "code": "useEffect(() => {  // Your Effect connected to the room specified with roomId...  const connection = createConnection(serverUrl, roomId);  connection.connect();  return () => {    // ...until it disconnected    connection.disconnect();  };}, [roomId]);",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {  const connection = createConnection(serverUrl, roomId);  connection.connect();  return () => {    connection.disconnect();  };}); // compiler inserted dependencies.",
      "language": "javascript"
    },
    {
      "code": "const value = use(store);",
      "language": "javascript"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/blog",
    "https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more",
    "https://react.dev/reference/react/ViewTransition",
    "https://react.dev/reference/react/addTransitionType",
    "https://react.dev/reference/react/Activity",
    "https://react.dev/reference/react/useTransition",
    "https://react.dev/community/versioning-policy",
    "https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022",
    "https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/reference/react/useEffectEvent",
    "https://react.dev/blog/2025/10/07/react-compiler-1",
    "https://react.dev/blog/2025/10/01/react-19-2",
    "https://react.dev/blog/2025/02/14/sunsetting-create-react-app"
  ]
}